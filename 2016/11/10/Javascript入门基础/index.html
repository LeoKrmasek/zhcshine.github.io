<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="数据类型  object(包含Function，Array，Date等) number string boolean null undefined  类型检测 typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;q">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript入门基础">
<meta property="og:url" content="http://www.zhuohc.com/2016/11/10/Javascript入门基础/index.html">
<meta property="og:site_name" content="zhuohc&#39;s blog">
<meta property="og:description" content="数据类型  object(包含Function，Array，Date等) number string boolean null undefined  类型检测 typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;q">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-24T01:26:26.183Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript入门基础">
<meta name="twitter:description" content="数据类型  object(包含Function，Array，Date等) number string boolean null undefined  类型检测 typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;q">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>javascript入门基础</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2016/11/10/CentOs7.2服务器基础配置/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2016/11/10/Css兼容性汇总/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&text=javascript入门基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&is_video=false&description=javascript入门基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=javascript入门基础&body=Check out this article: http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&name=javascript入门基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&t=javascript入门基础"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型检测"><span class="toc-number">2.</span> <span class="toc-text">类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表达式"><span class="toc-number">3.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-number">4.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊运算符"><span class="toc-number">5.</span> <span class="toc-text">特殊运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语句"><span class="toc-number">6.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#严格模式待补充"><span class="toc-number">7.</span> <span class="toc-text">严格模式(待补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">8.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内部原型proto和构造器的原型prototype的关系"><span class="toc-number">9.</span> <span class="toc-text">对象的内部原型(proto)和构造器的原型（prototype）的关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象属性操作"><span class="toc-number">10.</span> <span class="toc-text">对象属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象属性标签"><span class="toc-number">11.</span> <span class="toc-text">对象属性标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象标签"><span class="toc-number">12.</span> <span class="toc-text">对象标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js对象与json格式转换"><span class="toc-number">13.</span> <span class="toc-text">JS对象与json格式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">14.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的方法"><span class="toc-number">15.</span> <span class="toc-text">数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建函数"><span class="toc-number">16.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">17.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call和apply"><span class="toc-number">18.</span> <span class="toc-text">call和apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">19.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">20.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种作用域"><span class="toc-number">21.</span> <span class="toc-text">三种作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es3中的执行上下文"><span class="toc-number">22.</span> <span class="toc-text">ES3中的执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype"><span class="toc-number">23.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">24.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">25.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟重载"><span class="toc-number">26.</span> <span class="toc-text">模拟重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用子类方法"><span class="toc-number">27.</span> <span class="toc-text">调用子类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现链式调用"><span class="toc-number">28.</span> <span class="toc-text">实现链式调用</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        javascript入门基础
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">zhuohc's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2016-11-10T02:19:51.000Z" itemprop="datePublished">2016-11-10</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/前端/">前端</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/javascript/">javascript</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="数据类型">数据类型</h3>
<blockquote>
<p>object(包含Function，Array，Date等)<br>
number<br>
string<br>
boolean<br>
null<br>
undefined</p>
</blockquote>
<h3 id="类型检测">类型检测</h3>
<p>typeof 基本类型，function， null可以用===判断</p>
<pre><code>typeof 100           // &quot;number&quot;   
typeof true          // &quot;boolean&quot;    
typeof function      // &quot;function&quot;    
typeof undefined     // &quot;undefined&quot;  
typeof new Object()  // &quot;object&quot;  
typeof [1, 2]        // &quot;object&quot;  
typeof NaN           // &quot;number&quot;  
typeof null          // &quot;object&quot;  </code></pre>
<p>instanceof</p>
<pre><code>// 不同window或iframe下返回false
[1, 2] instanceof Array === true  
new Object instanceof Array === fasle</code></pre>
<p>Object.prototype.toString</p>
<pre><code>Object.prototype.toString.apply([1, 2, 3]) === &quot;[object Array]&quot;;  
Object.prototype.toString.apply(function(){}) === &quot;[object Function]&quot;  
Object.prototype.toString.apply(null) === &quot;[object Null]&quot;  // ie678返回[object Object]  
Object.prototype.toString.apply(undefined) === &quot;[object Undefined]&quot;  
Object.prototype.toString.apply(12313) === &quot;[object Number]&quot;  
Object.prototype.toString.apply(&#39;12313&#39;) === &quot;[object String]&quot;</code></pre>
<p>constructor<br>
duck type</p>
<h3 id="表达式">表达式</h3>
<p>表达式是一种js短语，可使js解释器用来产生一个值</p>
<pre><code>// 原始表达式
3.14, &quot;test&quot;      // 常量，直接量
null, this, true  // 关键字
i, j, k;           // 变量

// 复合表达式
10 * 20;           // 原始表达式+运算符+原始表达式

// 初始化表达式
[1, 2];
[1,,2];
{x: 1, y: 2};

// 函数表达式
var fe = function(){};
(function(){console.log(&#39;1111&#39;);}){};

// 属性访问表达式
var o = {x:1};
o.x;
o[&#39;x&#39;];

// 调用表达式
func();

// 对象创建表达式
new Func(1, 2);
new Object;</code></pre>
<h3 id="运算符">运算符</h3>
<blockquote>
<p>一元（+num）<br>
二元（a + b）<br>
三元（c：a：b） 赋值(x += 1)<br>
比较(a == b)<br>
算术（a - b）<br>
位 （a | b）<br>
逻辑 (exp1 &amp;&amp; exp2)<br>
字符串("a" + "b")<br>
特殊</p>
</blockquote>
<h3 id="特殊运算符">特殊运算符</h3>
<blockquote>
<p>c? a:b<br>
var val = (1, 2, 3) // 逗号运算符<br>
delete obj.x // 删除对象属性<br>
'x' in window; // in 运算符<br>
instanceof, typeof // 判断类型<br>
new Foo(); // new 运算符<br>
this // this运算符<br>
void 0 // undefined</p>
</blockquote>
<h3 id="语句">语句</h3>
<p>块语句block<br>
块语句是没有作用域的</p>
<pre><code>{  
var str = &#39;hi&#39;;  
console.log(str);  
}  </code></pre>
<p>声明语句 var<br>
var a=1, b=1; 函数语句function</p>
<pre><code>// 函数声明语句  
function fd() {  
    return true;  
}    
// 函数表达式  
var fe = function() {
    //do sth
};</code></pre>
<p>for in 语句</p>
<pre><code>var p;  
var obj = {x:1, y:2};  
for(p in obj) {
    // 顺序不确定  
}</code></pre>
<p>swith语句</p>
<pre><code>var val = 2;
switch (val) {
    case 1:
        console.log(1);
        break;
    case 2:
        console.log(2);
        break;
    case 3:
        console.log(3);
        break;
    default:
        console.log(0);
        break;
}</code></pre>
<p>循环语句</p>
<pre><code>while (isTrue) {
    // do sth
}

do {
    // do sth
} while (isTrue)

var i;
for (i = 0; i &lt; n; i++) {
    // do sth
}</code></pre>
<p>with语句 // 不使用 try catch语句</p>
<pre><code>try {
    try {
        throw new Error(&#39;oops&#39;);
    } catch(ex) {
        console.error(&#39;inner catch&#39;, ex.message);
        throw ex;
    } finally {
        console.log(&#39;inner  finally&#39;);
    }
} catch(ex) {
    console.error(&#39;outer catch&#39;, ex.message);
} finally {
    console.log(&#39;outer finally&#39;);
}</code></pre>
<p>结果 内部catch&gt;内部finally&gt;外部catch&gt;外部finally</p>
<pre><code>inner catch oops  
inner  finally  
outer catch oops  
outer finally  </code></pre>
<h3 id="严格模式待补充">严格模式(待补充）</h3>
<pre><code>function func() {
    &#39;use strict&#39;;
}</code></pre>
<h3 id="对象">对象</h3>
<p>对象创建<br>
字面量创建</p>
<pre><code>var obj = {x: 1};
console.log(obj);
console.log(obj.y);
Object.prototype.y = 2;
console.log(obj);
console.log(obj.y);
obj.y = undefined;
console.log(obj);
console.log(obj.y);


{ x: 1 }
undefined
{ x: 1 }
2
{ x: 1, y: undefined }
undefined</code></pre>
<p>new构造器创建</p>
<pre><code>function foo() { this.color = &#39;red&#39;;}
foo.prototype.background = &#39;#000&#39;;
var redColor = new foo();
console.log(redColor);
console.log(typeof redColor.toString);
console.log(redColor.color);
console.log(redColor.background);
console.log(foo);
console.log(foo.prototype);
console.log(foo.prototype.prototype);
console.log(&#39;background&#39; in redColor);
redColor.background = &#39;#FFF&#39;;
console.log(redColor.background);
console.log(foo.prototype.background);


foo { color: &#39;red&#39; }
function
red
#000
[Function: foo]
foo { background: &#39;#000&#39; }
undefined
true
#FFF
#000</code></pre>
<p>Object.create()创建</p>
<pre><code>function obj() {
    this.x = 1;
}
console.log(obj);
var obj1 = new obj();
console.log(obj1);
var obj2 = Object.create(obj);
console.log(obj2);
console.log(obj2.x);
var obj3 = Object.create(obj1);
console.log(obj3);
console.log(obj3.x);;


[Function: obj]
obj { x: 1 }
Function {}
undefined
obj {}
1</code></pre>
<h3 id="对象的内部原型proto和构造器的原型prototype的关系">对象的内部原型(<strong>proto</strong>)和构造器的原型（prototype）的关系。</h3>
<p>一、所有构造器/函数的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</p>
<pre><code>Number.__proto__ === Function.prototype  // true  
Boolean.__proto__ === Function.prototype // true  
String.__proto__ === Function.prototype  // true  
Object.__proto__ === Function.prototype  // true  
Function.__proto__ === Function.prototype // true  
Array.__proto__ === Function.prototype   // true  
RegExp.__proto__ === Function.prototype  // true  
Error.__proto__ === Function.prototype   // true  
Date.__proto__ === Function.prototype    // true  
Math.__proto__ === Object.prototype  // true  
JSON.__proto__ === Object.prototype  // true 
// 函数声明
function Person() {}
// 函数表达式
var Man = function() {}
console.log(Person.__proto__ === Function.prototype) // true  
console.log(Man.__proto__ === Function.prototype)    // true  </code></pre>
<p>所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）</p>
<pre><code>console.log(typeof Function.prototype) // function
console.log(typeof Object.prototype)   // object
console.log(typeof Number.prototype)   // object
console.log(typeof Boolean.prototype)  // object
console.log(typeof String.prototype)   // object
console.log(typeof Array.prototype)    // object
console.log(typeof RegExp.prototype)   // object
console.log(typeof Error.prototype)    // object
console.log(typeof Date.prototype)     // object
console.log(typeof Object.prototype)   // object  
console.log(Function.prototype.__proto__ === Object.prototype) // true    
Object.prototype.__proto__ === null  // true  </code></pre>
<p>二、所有对象的<strong>proto</strong>都指向其构造器的prototype<br>
JavaScript引擎内置构造器</p>
<pre><code>var obj = {name: &#39;jack&#39;}
var arr = [1,2,3]
var reg = /hello/g
var date = new Date
var err = new Error(&#39;exception&#39;)

console.log(obj.__proto__ === Object.prototype) // true
console.log(arr.__proto__ === Array.prototype)  // true
console.log(reg.__proto__ === RegExp.prototype) // true
console.log(date.__proto__ === Date.prototype)  // true
console.log(err.__proto__ === Error.prototype)  // true</code></pre>
<p>自定义的构造器</p>
<pre><code>function Person(name) {
    this.name = name
}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === Person.prototype) // true</code></pre>
<p>每个对象都有一个constructor属性，可以获取它的构造器</p>
<pre><code>function Person(name) {
    this.name = name
}
var p = new Person(&#39;jack&#39;)
console.log(p.__proto__ === p.constructor.prototype) // true</code></pre>
<h3 id="对象属性操作">对象属性操作</h3>
<p>属性读写</p>
<pre><code>// 属性读写
var obj = {x1: 1, x2: 2};
var i = 1, n = 2;
for(; i&lt;= n; i++) {
    console.log(obj[&#39;x&#39; + i]);
}
// 输出1，2

var p;
for(p in obj) {
    console.log(obj[p]);
}
// 输出1，2

var obj = {x: 1};
// 读写异常
console.log(obj.y); // undefined
var yz = obj.y.z;  // TypeError: Cannot read property &#39;z&#39; of undefined
obj.y.z = 2;      //TypeError: Cannot set property &#39;z&#39; of undefined
// 正确方式
var yz;
if(obj.y) {
    yz = obj.y.z;
}
// 或者
var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z  // 这个会返回undefined</code></pre>
<p>属性删除</p>
<pre><code>var person = {age: 28, title: &#39;fe&#39;};
console.log(delete person.age);  // true
console.log(delete person[&#39;age&#39;]);  // true
console.log(person.age);  // undefined
console.log(delete person.age);   // 注意这个也返回true 判断操作结束后该属性是否存在

// 有些属性是不能删除的
console.log(delete Object.prototype);  // false

// 原因
var descriptor = Object.getOwnPropertyDescriptor(Object, &#39;prototype&#39;);
console.log(descriptor.configurable);  // false

// 变量及函数不可删除
var globalVal = 1;
console.log(delete globalVal);  // false

(function() {
    var localVal = 1;
    console.log(delete localVal);
}());  // false

function fd() {}
console.log(delete fd);  // false

(function() {
    function fd() {};
    console.log(delete fd);
}());  // false


// 隐示定义的变量可以
ohNo = 1;
console.log(delete ohNo);  // true</code></pre>
<p>对象属性检测</p>
<pre><code>var cat = new Object();
cat.legs = 4;
cat.name = &#39;Kitty&#39;;

console.log(&#39;legs&#39; in cat);  // true
console.log(&#39;abc&#39; in cat);  // false
console.log(&#39;toString&#39; in cat);  // true 继承属性

console.log(cat.hasOwnProperty(&#39;legs&#39;));  // true
console.log(cat.hasOwnProperty(&#39;toString&#39;));  // false

console.log(cat.propertyIsEnumerable(&#39;legs&#39;));  // true
console.log(cat.propertyIsEnumerable(&#39;toString&#39;));  // false


Object.defineProperty(cat, &#39;price&#39;, {enumerable: false, value: 1000});
// defineProperty是Object的方法，默认的标签enumerable值为false
// Object.x创建属性，默认的标签值为true
console.log(cat.propertyIsEnumerable(&#39;price&#39;));  // false
console.log(cat.hasOwnProperty(&#39;price&#39;));  // true


// 判断属性是否存在
if(cat &amp;&amp; cat.legs) {
    cat.legs *= 2;
}

if(cat.legs != undefined) {
    // !== undefined 或者 !== null
}
if(cat.legs !== undefined) {
    // !== undefined
}</code></pre>
<p>对象属性枚举</p>
<pre><code>var o = {x: 1, y: 2, z: 3};
console.log(&#39;toString&#39; in o);  // true
o.propertyIsEnumerable(&#39;toString&#39;);  // false

var key;
console.log(o.x);  // 1
console.log(o.y);  // 2
console.log(o.z);  // 3
for(key in o) {
    console.log(key);  // x, y, z
    console.log(o.key);  // undefined
    console.log(o[key]);  // 1, 2, 3
}


var obj = Object.create(o);
obj.a = 4;
var key;
for(key in obj) {
    console.log(key); // a, x, y, z
}
var key1;
for (key1 in obj) {
    if(obj.hasOwnProperty(key1)) {
        console.log(key1); // a
    }
}</code></pre>
<p>对象属性的get/set方法</p>
<pre><code>// 对象属性的get/set方法
var man = {
    name: &#39;Bug&#39;,
    weibo: &#39;Bug&#39;,
    get age() {
        return new Date().getFullYear() - 1988;
    },
    set age(val) {
        console.log(&#39;cannot be set &#39; + val);
    },
};

console.log(man.age);  // 调用age的get方法27
man.age = 100;  // 调用age的set方法 cannot be set 100
console.log(man.age);  // 27


var man = {
    weibo: &#39;Bug&#39;,
    $age: null,
    get age() {
        if(this.$age == undefined) {
            return new Date().getFullYear() - 1988;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val; // 转为数字
        if(!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = + val;
        } else {
            throw new Error(&#39;Incorrect val = &#39; + val );
        }
    }
}

console.log(man.age);  // 27
man.age = 100;
console.log(man.age);  // 100
//man.age = &#39;abc&#39;;  // Error: Incorrect val = NaN


// get/set方法与原型链

// 这是错误的定义对象属性get方法方式
function foo1() {}
foo1.prototype.z = {
    get: function() {
        return 2;
    }
};
var obj = new foo1();
console.log(obj.z);  // 这个会被认为是对象 { get: [Function] }
obj.z = 200;
console.log(obj.z);  // 200

// 正确定义方法
function foo() {}
Object.defineProperty(foo.prototype, &#39;z&#39;, {
    get: function() {
        return 1;
    },
    // configurable: true,  // 开启此属于也不会被改变
    // writable: true,  // 此项不能配置writable/value get/set 二选一
 });
var obj = new foo();
console.log(obj.z);   // 1
obj.z = 100;
console.log(obj.z);  // 但是还是1 并没有被改变

Object.defineProperty(obj, &#39;z&#39;, {
    value: 100,
    configurable: true
});
console.log(obj.z);  // 100
delete obj.z;
console.log(obj.z);  // 返回到1

// 另外一个例子
var o = {};
Object.defineProperty(o, &#39;x&#39;, {
    value: 1
});  // 默认writable: false, configurable: false
var obj = Object.create(o);
console.log(obj.x);  // 1
obj.x = 100;
console.log(obj.x);  // 还是1


Object.defineProperty(obj, &#39;x&#39;, {
    writable: true,
    configurable: true,
    value: 100
});
console.log(obj.x);  // 100
obj.x = 200;
console.log(obj.x); // 200</code></pre>
<h3 id="对象属性标签">对象属性标签</h3>
<pre><code>person = {};
Object.defineProperty(person, &#39;type&#39;, {
    configurable: false,
    writable: true,
    enumerable: false,
    value: &#39;Object&#39;,
});

console.log(Object.keys(person));   // [] 返回空数组，不能枚举
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));   // { value: &#39;Object&#39;, writable: true, enumerable: false, configurable: false }


// writable为true，可以通过赋值方法修改value值 [通过赋值修改属性值只和writable标签有关，和configurable无关]
person.type = &#39;Object2&#39;;
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));  // { value: &#39;Object2&#39;, writable: true, enumerable: false, configurable: false }


// configurable: false 无法使用delete删除属性， 无法使用get/set方法，  无法重新配置属性标签（除了将writable从true修改为false）
console.log(delete person.type);   // 返回false


// 只有writable和configurable标签都为false时，不能修改value标签值，其他情况都可以修改value标签值
Object.defineProperty(person, &#39;type&#39;, {
    configurable: false,
    writable: true,
    enumerable: false,
    value: &#39;Object1&#39;,
});
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));   // { value: &#39;Object1&#39;, writable: true, enumerable: false, configurable: false }


// 可以重新配置writable标签值(只能重true改为false)
Object.defineProperty(person, &#39;type&#39;, {
    writable: false,
});
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));   // { value: &#39;Object1&#39;, writable: false, enumerable: false, configurable: false }


// 无法将writable从false改为true
Object.defineProperty(person, &#39;type&#39;, {
    writable: true,
});
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));   // TypeError: Cannot redefine property: type


// 无法重新配置enumerable，configurable属性
Object.defineProperty(person, &#39;type&#39;, {
    enumerable: true,
});
console.log(Object.getOwnPropertyDescriptor(person, &#39;type&#39;));   // TypeError: Cannot redefine property: type</code></pre>
<h3 id="对象标签">对象标签</h3>
<p>原型标签<strong>proto</strong></p>
<pre><code>// 原型标签__proto__

function Person(name) {
    this.name = name;
}
var p = new Person(&#39;jack&#39;);
console.log(p.__proto__ === Person.prototype);  // true</code></pre>
<p>类型标签</p>
<pre><code>//  对象class标签，表示对象是哪个类型，没有直接的方法去修改或者获取
var toString = Object.prototype.toString;

console.log(toString.call(null));  // [object Null]
console.log(toString.call(undefined));  // [object Undefined]
console.log(toString.call(1));  // [object Number]
console.log(toString.call(new Number(1)));  // [object Number]
console.log(toString.call(true));  // [object Boolean]
console.log(toString.call(new Boolean(true)));  // [object Boolean]</code></pre>
<p>可扩展标签</p>
<pre><code>// extensible 可扩展标签，表示是否可以继续添加对象属性
var obj = {x: 1, y: 2};
console.log(Object.isExtensible(obj));  // true 对象可扩展
Object.preventExtensions(obj);  // 配置对象不可扩展
console.log(Object.isExtensible(obj));  // false 对象不可扩展
obj.z =1;
console.log(obj.z);  // undefined 添加属性失败
console.log(Object.getOwnPropertyDescriptor(obj, &#39;x&#39;));  // // { value: 1, writable: true, enumerable: true, configurable: true }


// Object.seal方法，对象的所有属性configurable值为false
Object.seal(obj);
console.log(Object.getOwnPropertyDescriptor(obj, &#39;x&#39;));  // { value: 1, writable: true, enumerable: true, configurable: false }
console.log(Object.isSealed(obj)); // true


// Object.freeze方法，对象的所有属性configurable，writable标签值为false
Object.freeze(obj);
console.log(Object.getOwnPropertyDescriptor(obj, &#39;x&#39;));   // // { value: 1, writable: false, enumerable: true, configurable: false }
console.log(Object.isFrozen(obj));  // true</code></pre>
<h3 id="js对象与json格式转换">JS对象与json格式转换</h3>
<pre><code>// 将js对象转为json格式JSON.stringify()
var obj = {x: 1, y: true, z: [1, 2, 3], nullVal: null};
console.log(JSON.stringify(obj));  // {&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}

// undefined,NaN,Infinity等特殊属性值
var obj = {val: undefined, a: NaN, b: Infinity, c: new Date()};
console.log(JSON.stringify(obj));  // {&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-12-19T12:30:40.456Z&quot;}

// 将json格式转为js对象JSON.parse
var obj = JSON.parse(&#39;{&quot;x&quot;: 1}&#39;);
console.log(obj.x);  // 1

//toJSON方法
var obj = {
    x: 1,
    y: 2,
    o: {
        o1: 1,
        o2: 2,
        toJSON: function() {
            return this.o1 + this.o2;
        }
    },
};
console.log(JSON.stringify(obj));  // {&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}</code></pre>
<p>###toString valueOf方法</p>
<pre><code>// 对象在作为操作数时，解释器总是优先调用valueOf()--(Date类型的对象在二元“+”运算时例外),而其他情况，解释器总是认为我们想要的是字符串，所以会优先调用toString()。
var obj = {x: 1, y: 2};
console.log(obj.toString());  // [object Object]
console.log(+obj.toString());  // NaN
console.log(3 + obj.toString());  // 3[object Object] 会被理解为字符串拼接
console.log(+obj.valueOf());  // NaN

// 重写
obj.toString = function() {
    return this.x + this.y;
};
console.log(+obj);  // 3
obj.valueOf = function() {
    return this.x + this.y + 100;
};
console.log(+obj);  // 103

// 如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。

var cc = {
    i: 10,
    valueOf: function() {
        console.log(&#39;valueOf&#39;);
        return this.i;
    }
};

console.log(cc);// 10 { [Number: 10] i: 10, valueOf: [Function] }
console.log(+cc); // 10 valueOf
console.log(&#39;&#39;+cc); // 10 valueOf
console.log(String(cc)); // [object Object]
console.log(Number(cc)); // 10 valueOf
console.log(cc == &#39;10&#39;); // true valueOf</code></pre>
<h3 id="数组">数组</h3>
<p>创建数组</p>
<pre><code>// 字面量创建数组 数组的长度不能超过2^23 - 1 = 4,294,967,295
var BAT = [&#39;B&#39;, &#39;A&#39;, &#39;T&#39;];
var students = [{name: &#39;B&#39;, age: 27}, {name: &#39;A&#39;, age: 30}];
var arr = [&#39;T&#39;, 123, true, null, undefined];
var arrInArr = [[1, 2], [1, 2, 3]];

// 对象创建数组 new关键字可以省略
var arr = new Array();  // var = [];
var arrWithLength = new Array(100);  // undefined * 100
var arrLikesLiteral = new Array(true, false, null, 1, 2, &#39;hi&#39;);  // [true, false, null, 1, 2, &#39;hi&#39;]</code></pre>
<p>数组元素操作</p>
<pre><code>// 数组元素读写

// 索引访问
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr[1]);  // b
console.log(arr.length);  // 5
arr[5] = &#39;f&#39;;
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
console.log(arr.length);  // 6

// delete方法并不会改变数组长度,delete 和定义为undefined的区别
delete arr[0];
console.log(arr);  // [ , &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
console.log(arr.length);  // 6
console.log(0 in arr);  // 会返回false
arr[1] = undefined;
console.log(arr);  // [ , undefined, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
console.log(arr.length);  // 6
console.log(1 in arr);  // true

// 数组是动态的，无需指定大小

// 指定索引位置，改变数组
var arr = [];
arr[1] = &#39;b&#39;;
console.log(arr.length);  // 2
console.log(arr);   // [ , &#39;b&#39; ]

// push方法，在数组尾部添加元素,并返回新的数组长度
console.log(arr.push(&#39;c&#39;));  // 3
console.log(arr);  // [ , &#39;b&#39;, &#39;c&#39; ]

// 在数组尾部添加的另一种方法
arr[arr.length] = &#39;d&#39;;
console.log(arr);  // [ , &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]

// unshift方法，在数组头部添加元素，并返回新的数组长度
console.log(arr.unshift(&#39;a&#39;));  // 5
console.log(arr);  // [ &#39;a&#39;, , &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ]

// pop方法，删除数组尾部的元素并返回这个元素
console.log(arr.pop());  // &#39;d&#39;
console.log(arr);  // [ &#39;a&#39;, , &#39;b&#39;, &#39;c&#39; ]

// 删除数组尾部元素的另个方法
arr.length -= 1;
console.log(arr);  // [ &#39;a&#39;, , &#39;b&#39; ]

// shift方法，删除数组头部的元素并返回这个元素
console.log(arr.shift());  // &#39;a&#39;
console.log(arr);  // [ , &#39;b&#39; ]</code></pre>
<p>数组迭代</p>
<pre><code>// 数组迭代
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;];
for(var i = 0; i &lt; arr.length; i++) {
    console.log(arr[i]);
}
// a b c d e f g

for(i in arr) {
    console.log(arr[i]);
}
// a b c d e f g

// for in 表达式的坑：会迭代原型的元素
Array.prototype.x = &#39;keng&#39;;
for(i in arr) {
    console.log(arr[i]);
}
// a b c d e f g keng

for(i in arr) {
    if(arr.hasOwnProperty(i)) {
        console.log(arr[i]);
    }
}
// a b c d e f g</code></pre>
<p>特殊数组：二维数组和稀疏数组</p>
<pre><code>// 特殊数组：二维数组，稀疏数组
// 二维数组
var arr = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;], [&#39;e&#39;, &#39;f&#39;]];
var i = 0, j = 0;
var row;
for(; i &lt; arr.length; i++) {
    row = arr[i];
    console.log(&#39;row&#39; + i);
    for(j = 0; j &lt; row.length; j++) {
        console.log(row[j]);
    }
}
// row0 a b row1 c d row2 e f

// 稀疏数组：并不含有从0开始的连续索引
var arr1 = [undefined];
var arr2 = new Array(1);
console.log(0 in arr1);  // true
console.log(0 in arr2);  // false</code></pre>
<h3 id="数组的方法">数组的方法</h3>
<p>Array.prototype.join(separator)</p>
<pre><code>// Array.prototype.join(separator)方法：将数组拼接成字符串，返回字符串，不改变原数组
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
console.log(arr.join());  // a,b,c
console.log(arr.join(&#39;_&#39;));  // a,b,c
function repeatString(str, n) {
    return new Array(n + 1).join(str);
}
console.log(repeatString(&#39;a&#39;, 3));  // aaa
console.log(repeatString(&#39;Hi&#39;, 5));  // HiHiHiHiHi</code></pre>
<p>Array.prototype.reverse()</p>
<pre><code>// Array.prototype.reverse() 将数组逆序，返回数组本身，会改变数组本身
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
var arr1 = arr;
var arr2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
console.log(arr.reverse());  // [ &#39;c&#39;, &#39;b&#39;, &#39;a&#39; ]
console.log(arr);  // [ &#39;c&#39;, &#39;b&#39;, &#39;a&#39; ]
console.log(arr1);  // [ &#39;c&#39;, &#39;b&#39;, &#39;a&#39; ]
console.log(arr2);  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]</code></pre>
<p>Array.prototype.sort(sortby）</p>
<pre><code>// Array.prototype.sort(sortby)方法：接受一个函数参数(不传参数默认按字符编码顺序)，返回数组本身，会修改原数组
var arr = [&#39;f&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;a&#39;];
console.log(arr.sort());  // [ &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]

var arr = [13, 24, 51, 3];
console.log(arr.sort());  // [ 13, 24, 3, 51 ]

// 传入参数：比较函数(a, b)
// 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
// 若 a 等于 b，则返回 0。
// 若 a 大于 b，则返回一个大于 0 的值。
function sortNumber(a, b) {
    return a - b;
}
console.log(arr.sort(sortNumber));  // [ 3, 13, 24, 51 ]

var arr = [{age: 25}, {age: 29}, {age: 40}];
console.log(arr.sort(function sortAge(a, b) {
    return a.age - b.age;
}));  // [ { age: 25 }, { age: 29 }, { age: 40 } ]</code></pre>
<p>Array.prototype.concat(arrayX, arrayY.....)</p>
<pre><code>// Array.prototype.concat(arrayX, arrayY.....)方法 连接多个数组，返回一个新的数组，不会改变原数组
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
console.log(arr.concat(&#39;d&#39;, &#39;e&#39;));  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
console.log(arr.concat([&#39;d&#39;, &#39;e&#39;], &#39;f&#39;));  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; ]
console.log(arr.concat([&#39;d&#39;, &#39;e&#39;], [&#39;f&#39;, &#39;g&#39;]));  // &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39; ]
console.log(arr.concat([[&#39;d&#39;, &#39;e&#39;], &#39;f&#39;]));  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, [ &#39;d&#39;, &#39;e&#39; ], &#39;f&#39; ]
console.log(arr.concat([[[&#39;d&#39;, &#39;e&#39;], &#39;f&#39;], &#39;g&#39;]));  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, [ [ &#39;d&#39;, &#39;e&#39; ], &#39;f&#39; ], &#39;g&#39; ]</code></pre>
<p>Array.prototype.slice(start, end)</p>
<pre><code>// Array.prototype.slice(start, end)方法：左闭右开截取数组，返回一个新的数组，不改变原数组
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.slice(1, 3));  // [&#39;b&#39;, &#39;c&#39;]
console.log(arr.slice(1));  // [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
console.log(arr.slice(1, -1));  // [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
console.log(arr.slice(-4, -3));  // [&#39;b&#39;]</code></pre>
<p>Array.prototype.splice(index, howmany, item1,....itemX)</p>
<pre><code>// Array.prototype.splice(index, howmany, item1,....itemX)方法：
// 向/从数组中添加/删除项目，然后返回被删除的项目。会改变原数组
// index参数：必须，整数，添加或删除的位置，左闭合
// howmany参数：可选，设置为0，则不会删除
// item1,.....itemX：可选，向数组中添加的元素

var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice(2));   // [ &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39; ]

var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice(2, 1));  // [ &#39;c&#39; ]
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;d&#39;, &#39;e&#39; ]

var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice(2, 0));  // []
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice(2, 2, &#39;f&#39;, &#39;g&#39;, [&#39;h&#39;, &#39;i&#39;]));  // [ &#39;c&#39;, &#39;d&#39; ]
console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;g&#39;, [ &#39;h&#39;, &#39;i&#39; ], &#39;e&#39; ]

// 指定位置插入新的元素
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice(2, 0, &#39;f&#39;));  // []
console.log(arr); // [ &#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
console.log(arr.splice());  // []
console.log(arr); // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]</code></pre>
<p>Array.prototype.forEach()</p>
<pre><code>// Array.prototype.forEach()方法(ES5)：接收函数参数
// 函数的3个参数x: 元素值，index：元素索引，a 数组本身
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];
arr.forEach(function(x, index, a) {
    console.log(x + &#39;_&#39; + index + &#39;_&#39; + a);
});
// a_0_a,b,c,d,e b_1_a,b,c,d,e c_2_a,b,c,d,e d_3_a,b,c,d,e e_4_a,b,c,d,e</code></pre>
<p>Array.prototype.map()</p>
<pre><code>//Array.prototype.map()方法(ES5):接收函数参数,不会修改原数组
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
var arr1 = arr.map(function(x) {
    return x + &#39;like&#39;;
});

console.log(arr);  // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]
console.log(arr1);  // [ &#39;alike&#39;, &#39;blike&#39;, &#39;clike&#39; ]</code></pre>
<p>Array.prototype.filter()</p>
<pre><code>// Array.prototype.filter()过滤方法(ES5):接收函数参数，不修改原数组
var arr = [1,2,3,4,5,6,7,8,9,10];
var arr1 = arr.filter(function(x, index) {
    return index % 3 === 0 || x &gt;= 8;
});
console.log(arr1);  // [ 1, 4, 7, 8, 9, 10 ]
console.log(arr);  // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</code></pre>
<p>Array.prototype.every() &amp; Array.prototype.some()</p>
<pre><code>// Array.prototype.every() &amp; Array.prototype.some()判断方法(ES5):接收函数参数，不修改原数组
// every 全部符合条件  some 只需一个符合条件
var arr = [1,2,3,4,5];
console.log(arr.every(function(x) {
    return x &lt; 10;
}));  // true
console.log(arr.every(function(x) {
    return x &lt;= 3;
}));  // false
console.log(arr.some(function(x) {
    return x === 3;
}));  // true
console.log(arr.some(function(x) {
    return x === 100;
}));  // false</code></pre>
<p>Array.prototype.reduce(function, index) Array.prototype.reduceRight(function, index)</p>
<pre><code>// Array.prototype.reduce(function, index) Array.prototype.reduceRight(function, index)方法
// 接收一个函数参数和一个数组索引参数，并返回一个值，不修改原数组
// 函数参加接收2个参数分别代表2个索引
// 索引参数表示从第index个元素开始
var arr = [1, 2, 3];
var sum = arr.reduce(function(x, y) {
    return x + y;
}, 0);
console.log(sum);  // 6  1+2返回3 3+3 返回6

var arr = [3, 9, 6];
var max = arr.reduce(function(x, y) {
    console.log(x + &#39;|&#39; + y);
    return x &gt; y ? x : y;
});
// 3|9
// 9|6
console.log(max);  // 9

var max = arr.reduceRight(function(x, y) {
    console.log(x + &#39;|&#39; + y);
    return x &gt; y ? x : y;
});
// 6|9
// 9|3
console.log(max);  // 9</code></pre>
<p>Array.prototype.indexOf(value, index) Array.prototype.lastIndexOf(value, index)</p>
<pre><code>// Array.prototype.indexOf(value, index) Array.prototype.lastIndexOf(value, index)数字检索方法
// value参数表示要查找的元素值，index表示从第几个索引位置开始查找(闭合)
var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;];
console.log(arr.indexOf(&#39;b&#39;));  // 1 在数组中查找是否有元素值为&#39;b&#39;，有则返回这个元素索引
console.log(arr.indexOf(&#39;f&#39;));  // -1 如果没有则返回-1
console.log(arr.indexOf(&#39;b&#39;, 1));  // 1 从第2个元素开始查找，返回索引1
console.log(arr.indexOf(&#39;b&#39;, 2));  // 3
console.log(arr.indexOf(&#39;b&#39;, -2));  // 3
console.log(arr.indexOf(&#39;b&#39;, -4));  // 1
console.log(arr.indexOf(&#39;b&#39;, -8));  // 1
console.log(arr.lastIndexOf(&#39;b&#39;));  // 3</code></pre>
<p>Array.isArray()</p>
<pre><code>// Array.isArray() 判断是否为数组
console.log(Array.isArray([]));  // true</code></pre>
<h3 id="创建函数">创建函数</h3>
<pre><code>// 函数声明
function add(a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
}

// 函数表达式
var add = function(a, b) {
    // do sth
};

// IEF(立即执行函数表达式)
(function() {
    // do sth
})();

// 函数表达式
return function () {
    // do sth
};

// NFE(命名式函数表达式)
var add = function foo(a, b) {
    // do sth
};</code></pre>
<p><strong>函数声明和函数表达式区别：函数声明会前置</strong></p>
<pre><code>var num = add(1, 2);
console.log(num);

function add(a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
}

// 结果为3


var num = add(1, 2);
console.log(num);

var add = function (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
};

// TypeError: add is not a function</code></pre>
<h3 id="this">this</h3>
<p>全局下的this</p>
<pre><code>// 全局下的this(浏览器下)
console.log(this.window === document);  // true
console.log(this === window);  // true
this.a = 37;
console.log(window.a);  // 37</code></pre>
<p>一般函数的this</p>
<pre><code>// 一般函数的this（浏览器下）
function f1() {
    return this;
}
f1() === window;  // true

function f2() {
    &quot;use strict&quot;;  // 严格模式下
    return this
}
f2() === undefined;  // true</code></pre>
<p>作为对象方法的函数的this</p>
<pre><code>var o = {
    prop: 37,
    f: function() {
        return this.prop;
    }
};
console.log(o.f());  // 37

var o = {prop: 37};
function  independent() {
    return this.prop;
}
o.f = independent;
console.log(o.f());  // 37</code></pre>
<p>原型链上的this</p>
<pre><code>var o = {
    f: function() {
        return this.a + this.b;
    }
};
var p = Object.create(o); // p为空对象，其原型会指向o
p.a = 1;
p.b = 4;
console.log(p.f())  // 5</code></pre>
<p>构造器中的this</p>
<pre><code>// 当new的函数构造器没有return返回值或者返回值不是对象时，new返回一个this指向构造器的prototype这样一个空对象
// 如果return返回的是对象 new返回的这是这个对象
function Myclass() {
    this.a = 37;
}
var o = new Myclass();
console.log(o.a);  // 37

function C2() {
    this.a = 37;
    return {a: 38};
}
o = new C2();
console.log(o.a);  // 38</code></pre>
<p>call和apply的this</p>
<pre><code>function add(c, d) {
    return this.a + this.b + c + d;
}
var o = {a: 1, b: 2};
add.call(o, 5, 6);  // 1+3+5+7=16
add.apply(o, [10, 20]);  //1+3+10+20=34

function bar() {
    console.log(Object.prototype.toString.call(this));
}
bar.call(7); // [object Number]</code></pre>
<p>band和this</p>
<pre><code>//bind是es5后，ie9+使用
function f() {
    return this.a;
}
var g = f.bind({a: &#39;test&#39;});
console.log(g());  // test
var o = {
    a: 37,
    f: f,
    g: g
};
console.log(o.f(), o.g());  // 37, test</code></pre>
<p>函数arguments属性</p>
<pre><code>function foo(x, y, z) {
    arguments.length;  // 2 实际传入的参数数量
    arguments[0];  // 1 传入第一个参数值
    arguments[0] = 10;
    x;  // 10 将第一个参数值修改为10， 严格模式下任然是1
    arguments[2] = 100;
    z; // undefined  由于第三个参数没有传入，不会绑定
    arguments.callee  === foo;  // true   严格模式下不能使用
}

foo(1, 2);
foo.length;  // 3   3个参数
foo.name;  // &quot;foo&quot; 函数名</code></pre>
<h3 id="call和apply">call和apply</h3>
<pre><code>// apply和call方法（浏览器）
// 第一个参数是作为this的对象，如果不是对象，会转换为对象
// call传入的是扁平传入参数
// apply第二个参数树数组
function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2);  // 1, 2, Number(100)
foo.apply(true, [3, 4]);  //3, 4, Boolean(true)
foo.apply(null);  // undefined, undefined, window
foo.apply(undefined);  // undefined, undefined, window</code></pre>
<h3 id="bind">bind</h3>
<p>bind方法：改变this</p>
<pre><code>// bind方法
this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return this.x;
    }
};

module.getX();  // 81 this指向module

var getX = module.getX;
getX();  // 9 this指向全局变量

var boundGetX = getX.bind(module);
boundGetX();  // 81  bind改变this指向</code></pre>
<p>bind方法：科里化</p>
<pre><code>// bind方法
function add(a, b, c) {
    return a+b+c;
}

var func = add.bind(undefined, 100);
func(1, 2);  // 103  undefined传给this， 100传给第一个参数a

var func2 = func.bind(undefined, 200);
func2(10);  // 310 undefined传给this，200传给b</code></pre>
<p>bind与new</p>
<pre><code>// bind方法与new
function foo() {
    this.b = 100;
    return this.a;
}

var func = foo.bind({a: 1});

func(); // 1  foo.bind后this指向{a: 1} return this.a = 1
new func();  // {b: 100} new调用将返回一个this，this会被初始化一个空对象，并且其原型是foo.prototype,空对象的b属性为100</code></pre>
<h3 id="闭包">闭包</h3>
<p>闭包基本概念</p>
<pre><code>// 闭包
var n = 999;
function f1() {
    console.log(n);
}
f1();  // 999  函数内部可以访问全局变量

function f1() {
    var n = 999;
}
console.log(n);  // error  函数外部无法访问函数内部局部变量

function f1() {
    n = 999;
}
console.log(n); // 999 因为没有使用var语句，相当于定义一个全局变量


// 简单的闭包原型
function f1() {
    var n = 999;
    function f2() {
        console.log(n);
    }
    return f2
}
var result = f1();
result();  // 999</code></pre>
<p>闭包案例</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color: rosybrown;
        }
        #div2 {
            background-color: aquamarine;
        }
        #div3 {
            background-color: yellowgreen;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;script&gt;
    document.body.innerHTML = &#39;&lt;div id=&quot;div1&quot;&gt;aaa&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;ccc&lt;/div&gt;&#39;;
    for(var i = 1; i &lt; 4; i++) {
        alert(i);  // 结果为1，2，3
        document.getElementById(&#39;div&#39; + i).
                addEventListener(&#39;click&#39;, function() {
            alert(i);  // 点击div1，div2，div3结果都是4,因为addEventListener的回调函数执行时i都为4
        });
    }
&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>正确写法</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color: rosybrown;
        }
        #div2 {
            background-color: aquamarine;
        }
        #div3 {
            background-color: yellowgreen;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;script&gt;
    document.body.innerHTML = &#39;&lt;div id=&quot;div1&quot;&gt;aaa&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;ccc&lt;/div&gt;&#39;;
    for(var i = 1; i &lt; 4; i++) {
        !function(i) {
            alert(i);  // 1,2,3
            document.getElementById(&#39;div&#39; + i).
               addEventListener(&#39;click&#39;, function() {
                   alert(i);  // 1, 2,3 
            });
        }(i);
    }
&lt;/script&gt;
&lt;/html&gt;</code></pre>
<p>闭包中的封装</p>
<pre><code>(function() {
    var _userID = 23245;
    var _typeID = &#39;item&#39;;
    var exportID = {};

    function converter(userID) {
        return +userID;
    }

    exportID.getUserID = function() {
        return converter(_userID);
    };

    exportID.getTypeID = function() {
        return _typeID;
    };
    global.exportID = exportID;
}());

console.log(exportID.getUserID());  //23245
console.log(exportID._userID);  // undefined</code></pre>
<h3 id="三种作用域">三种作用域</h3>
<pre><code>// 作用域： 全局作用域，函数作用域，eval作用域
var a = 10;
(function() {
    var b = 20;
})();
console.log(a);  // 10
console.log(b);  // error

for(var item in {a: 1, b: 2}) {
    console.log(item);  // a, b
}
console.log(item); // b</code></pre>
<h3 id="es3中的执行上下文">ES3中的执行上下文</h3>
<p>EC = Execution Context 执行上下文<br>
变量对象（Variable Object 简写VO）是一个抽象概念，用于存储执行上下文中的变量，函数声明，函数参数</p>
<pre><code>var a = 10;
function test(x) {
    var b = 20;
}
test(30);</code></pre>
<p>对应的上下文</p>
<pre><code>// 整个js环境中的VO
VO(globalContext) = {
    a: 10,
    test: &lt;ref to function&gt;
};
// 执行test(30)的VO
VO(test functionContext) = {
    x: 30,
    b: 20
};</code></pre>
<p>全局执行上下文</p>
<pre><code>VO(globalContext) === [[global]]
[[global]] = {
    Math : &lt;...&gt;,
    String : &lt;...&gt;,
    isNaN: function() {[Native Code]},
    ...
    ...
    window: global
};

String(10);  //[[global]].String(10)
window.a = 10;  // [[global]].window.a = 10
this.b = 20;  // [[global]].b = 20</code></pre>
<p>变量初始化阶段</p>
<pre><code>// 1, 函数参数（若没有传入，则其值为undefined）
// 2, 函数声明（若函数声明和函数参数冲突，则函数声明会覆盖掉函数参数）
// 3，变量声明（初始化变量值为undefined，若何函数参数，函数声明冲突，会被忽略掉）
function test(a, b) {
    var c = 10;
    function d() {}
    var e = function _e() {};
    (function x() {});
    b = 20;
}
test(10);


AO(test) = {
    a: 10,
    b: undefined,
    c: undefined,
    d: &lt;ref to func &#39;d&#39;&gt;,
    e: undefined,
};</code></pre>
<p>变量初始化案例1</p>
<pre><code>function foo(x, y, z) {
    function x() {}
    console.log(x);
}

foo(100);  // [Function: x]
//
AO(foo) = {
    //x: 100,
    y: undefined,
    z: undefined,
    x: &lt;ref to func &#39;x&#39;&gt;,  // 函数声明x会覆盖掉参数声明 
}</code></pre>
<p>变量初始化案例2</p>
<pre><code>function foo(x, y, z) {
    function func() {}
    var func;
    console.log(func);
}
foo(100);  // [Function: func]

function foo(x, y, z) {
    function func() {}
    var func = 1;
    console.log(func);
}
foo(100);  // 1  执行阶段会执行func = 1 这个语句</code></pre>
<p>代码执行阶段</p>
<pre><code>function test(a, b) {
    var c = 10;
    function d() {}
    var e = function _e() {};
    (function x() {})();
    b = 20;
}

// 初始化阶段
AO(test) = {
    a: 10,
    b: undefined,
    c: undefined,
    d: &lt;ref to func &#39;d&#39;&gt;,
    e: undefined
};
// 代码执行阶段
AO(test) = {
    a: 10,
    b: 20,
    c: 10,
    d: &lt;reference to FunctionDeclaration &#39;d&#39;&gt;,
    e: function _e()
};</code></pre>
<p>全局执行上下文案例</p>
<pre><code>console.log(x);  // [Function: x]
var x = 10;  // 初始化阶段x: 冲突，被忽略
console.log(x);  // 10
x = 20;
function x() {}  // 初始化阶段x: &lt;ref to func &#39;x&#39;&gt;
console.log(x);  // 20
if (true) {
    var a = 1;  // 初始化阶段a: undefined
} else {
    var b = true;  // 初始化阶段b: undefined
}

console.log(a);  // 1
console.log(b);  // undefined</code></pre>
<h3 id="prototype">prototype</h3>
<p>prototype是函数对象上的预设的对象属性<br>
原型是对象上的原型，通常都是构造器的prototype属性<br>
实例</p>
<pre><code>function Abc() {
    this.y = 2;
    var z = 3;
}
console.log(Abc);  // [Function: Abc]
console.log(Abc.prototype);  // Abc {}
console.log(typeof Abc.prototype);  // object

Abc.prototype.x = 1;
console.log(Abc.prototype);  // Abc { x: 1 }

var obj1 = new Abc();
console.log(obj1.__proto__);  // Abc { x: 1 }
console.log(obj1.__proto__ === Abc.prototype);  // true  new构造器创建的对象的原型是构造器的prototype属性
console.log(obj1);  // Abc { y: 2 }
console.log(obj1.y);  // 2
console.log(obj1.x);  // 1</code></pre>
<h3 id="继承">继承</h3>
<p>实现继承的方法</p>
<pre><code>// 实现继承的方法
function Person() {
}

function Student() {
}

Student.prototype = Person.prototype;  // 错误，会影响被继承类的方法
Student.prototype = new Person();  // 错误，传参问题，因为Student是类，并不是实例

// 正确的方法
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
// Object.create()是es5的方法，下面是fix方法
if(!Object.create) {
    Object.create = function(proto) {
        function F() {}
        F.prototype = proto;
        return new F;
    };
}</code></pre>
<p>原型的继承方法</p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayNo = function() {
        console.log(this.name + &#39; say no&#39;);
    }
}

Person.prototype.hi = function() {
    console.log(&#39;Hi, my name is &#39; + this.name + &#39;,I\&#39;m &#39; + this.age + &#39; years old now&#39;);
};
Person.prototype.LEGS_NUM = 2;
Person.prototype.ARMS_NUM = 2;
Person.prototype.walk = function() {
    console.log(this.name + &#39; is walking...&#39;);
};

console.log(Person);  // [Function: Person]
console.log(Person.prototype);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }
var Jack = new Person();  // Person构造器没有return对象，所以返回的是this
Jack.sayNo();  // undefined say no
Jack.hi();  // Hi, my name is undefined,I&#39;m undefined years old now
Jack.walk();  // undefined is walking...
console.log(Jack);  // Person { name: undefined, age: undefined, sayNo: [Function] }
console.log(Jack.__proto__);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }

// 以下5行代码是js中对象继承的写法
function Student(name, age, className) {
    Person.call(this, name, age);  // 使用call方法调用父构造器函数
    this.className = className;
}
Student.prototype = Object.create(Person.prototype);   // 这个如果直接使用Student.prototype = Person.prototype，改变Student对象方法会改变Person对象的方法，因为他们指向的是同一个对象
Student.prototype.constructor = Student;

Student.prototype.hi = function() {
    console.log(&#39;Hi, my name is &#39; + this.name + &#39;, I\&#39;m&#39; + this.age + &#39; years old now, and from &#39; + this.className + &#39;.&#39;);
};
Student.prototype.learn = function(subject) {
    console.log(this.name + &#39; is learning &#39; + subject + &#39; at &#39; + this.className + &#39;.&#39;);
};

var Lussi = new Student(&#39;Lussi&#39;, 27, &#39;Class Tree&#39;);
Lussi.sayNo();  // Lussi say no
Lussi.hi();  // Hi, my name is Lussi, I&#39;m27 years old now, and from Class Tree.
Lussi.walk();  // Lussi is walking...
Lussi.learn(&#39;math&#39;);  // Lussi is learning math at Class Tree.
console.log(Lussi);  // Student {name: &#39;Lussi&#39;, age: 27, sayNo: [Function], className: &#39;Class Tree&#39; }
console.log(Lussi.__proto__);  // Student {constructor: [Function: Student], hi: [Function], learn: [Function] }
console.log(Lussi.__proto__.__proto__);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }
console.log(Lussi.__proto__.__proto__.__proto__);  // {}
console.log(Lussi.__proto__.__proto__.__proto__.__proto__);  // null  
// 改变prototype
Student.prototype.x = 101;  // 会影响已经创建实例的属性
console.log(Jack.x);  // undefined
console.log(Lussi.x);  // 101

Student.prototype = {y: 2};  // 不会影响已经创建实例的属性，但会影响新创建的实例，并且重新修改prototype.y属性也不会改变
console.log(Jack.y); // undefined
console.log(Lussi.y);  // undefined
var Lilei = new Student(&#39;Lilei&#39;, 24, &#39;Class three&#39;);
console.log(Lilei.x);  // undefined
console.log(Lilei.y);  // 2
Student.prototype.y = 100;
console.log(Lilei.y);  // 100
console.log(Lussi.y);  // undefined
Student.prototype.z = 30;
console.log(Lilei.z);  // 30
console.log(Lussi.z);  // undefined
Person.prototype.z = 40;
console.log(Lilei.z);  // 30
console.log(Lussi.z);  // 40
console.log(Jack.z);  // 40</code></pre>
<h3 id="instanceof">instanceof</h3>
<pre><code>// instanceof  左边是对象（如果不是，直接返回false），右边是构造器（如果不是，直接报错），判断构造器的prototype属性是否在对象的原型链上
console.log([1, 2] instanceof Array);  // true
console.log(1 instanceof Array);  // false
console.log(Array.prototype);  // []
console.log(new Object() instanceof Array);  //false
console.log(Object.prototype);  // {}
console.log(new Object() instanceof Object);  // true
console.log(new Array() instanceof Object);  // true</code></pre>
<h3 id="模拟重载">模拟重载</h3>
<pre><code>function Person() {
    var args = arguments;
    // 判断第一个传入的是不是对象，因为args[null]也返回object，所有需要判断是否为null
    if(typeof args[0] === &#39;object&#39; &amp;&amp; args[0]) {
        if(args[0].name) {
            this.name = args[0].name;
        }
        if(args[0].age) {
            this.age = args[0].age;
        }
    } else {
        if(args[0]) {
            this.name = args[0];
        }
        if(args[1]) {
            this.age = args[1];
        }
    }
}
Person.prototype.toString = function() {
    console.log(&#39;name=&#39; + this.name + &#39;, age=&#39; + this.age);
};

var LiLei = new Person(&#39;LiLei&#39;, 23);
var Hanmm = new Person({name: &#39;Hanmm&#39;, age: 21});
LiLei.toString();  // name=LiLei, age=23
Hanmm.toString();  // name=Hanmm, age=21</code></pre>
<h3 id="调用子类方法">调用子类方法</h3>
<pre><code>function Person(name) {
    this.name = name;
}
function Student(name, className) {
    this.className = className;
    Person.call(this, name);
}

Person.prototype.init = function() {
    console.log(&#39;Person.init&#39;);
};
Student.prototype.init = function() {
    console.log(&#39;Student.init&#39;);
    Person.prototype.init.apply(this, arguments);
};
var LiLei = new Student(&#39;LiLei&#39;, &#39;Class four&#39;);
console.log(LiLei);  // Student { className: &#39;Class four&#39;, name: &#39;LiLei&#39; }
LiLei.init();  // Student.init  Person.init</code></pre>
<h3 id="实现链式调用">实现链式调用</h3>
<pre><code>function ClassManager() {
    console.log(&#39;ClassManager&#39;);
    this.name = &#39;ClassName&#39;;
}
ClassManager.prototype.addClass = function(str) {
    console.log(&#39;class: &#39;  + str + &#39; added.&#39;);
    console.log(this);
    return this;  // this始终指向ClassManger类的实例
};

var manager = new ClassManager();
manager.addClass(&#39;A&#39;).addClass(&#39;B&#39;).addClass(&#39;C&#39;);  //class: A added. ClassManager { name: &#39;ClassName&#39; } class: B added. ClassManager { name: &#39;ClassName&#39; } class: C added. ClassManager { name: &#39;ClassName&#39; }</code></pre>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型检测"><span class="toc-number">2.</span> <span class="toc-text">类型检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表达式"><span class="toc-number">3.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符"><span class="toc-number">4.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#特殊运算符"><span class="toc-number">5.</span> <span class="toc-text">特殊运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语句"><span class="toc-number">6.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#严格模式待补充"><span class="toc-number">7.</span> <span class="toc-text">严格模式(待补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">8.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的内部原型proto和构造器的原型prototype的关系"><span class="toc-number">9.</span> <span class="toc-text">对象的内部原型(proto)和构造器的原型（prototype）的关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象属性操作"><span class="toc-number">10.</span> <span class="toc-text">对象属性操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象属性标签"><span class="toc-number">11.</span> <span class="toc-text">对象属性标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象标签"><span class="toc-number">12.</span> <span class="toc-text">对象标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js对象与json格式转换"><span class="toc-number">13.</span> <span class="toc-text">JS对象与json格式转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">14.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组的方法"><span class="toc-number">15.</span> <span class="toc-text">数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建函数"><span class="toc-number">16.</span> <span class="toc-text">创建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">17.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call和apply"><span class="toc-number">18.</span> <span class="toc-text">call和apply</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">19.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">20.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种作用域"><span class="toc-number">21.</span> <span class="toc-text">三种作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es3中的执行上下文"><span class="toc-number">22.</span> <span class="toc-text">ES3中的执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype"><span class="toc-number">23.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">24.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">25.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模拟重载"><span class="toc-number">26.</span> <span class="toc-text">模拟重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用子类方法"><span class="toc-number">27.</span> <span class="toc-text">调用子类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现链式调用"><span class="toc-number">28.</span> <span class="toc-text">实现链式调用</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&text=javascript入门基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&is_video=false&description=javascript入门基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=javascript入门基础&body=Check out this article: http://www.zhuohc.com/2016/11/10/Javascript入门基础/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&title=javascript入门基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&name=javascript入门基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://news.ycombinator.com/submitlink?u=http://www.zhuohc.com/2016/11/10/Javascript入门基础/&t=javascript入门基础"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 zhuohanchang
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
