<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Javascript基础入门 | zhuohc.com</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型 object(包含Function，Array，Date等)numberstringbooleannullundefined  类型检测typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;quot;">
<meta name="keywords" content="javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript基础入门">
<meta property="og:url" content="http://www.zhuohc.com/2016/11/10/javascript-e5-9f-ba-e7-a1-80-e5-85-a5-e9-97-a8/index.html">
<meta property="og:site_name" content="zhuohc.com">
<meta property="og:description" content="数据类型 object(包含Function，Array，Date等)numberstringbooleannullundefined  类型检测typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;quot;">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-23T05:51:43.847Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript基础入门">
<meta name="twitter:description" content="数据类型 object(包含Function，Array，Date等)numberstringbooleannullundefined  类型检测typeof 基本类型，function， null可以用===判断 typeof 100           // &amp;quot;number&amp;quot;    typeof true          // &amp;quot;boolean&amp;quot;">
  
    <link rel="alternate" href="/atom.xml" title="zhuohc.com" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zhuohc.com</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我的个人网站</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.zhuohc.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-javascript-e5-9f-ba-e7-a1-80-e5-85-a5-e9-97-a8" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/10/javascript-e5-9f-ba-e7-a1-80-e5-85-a5-e9-97-a8/" class="article-date">
  <time datetime="2016-11-10T02:19:51.000Z" itemprop="datePublished">2016-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Javascript基础入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>object(包含Function，Array，Date等)<br>number<br>string<br>boolean<br>null<br>undefined</p>
</blockquote>
<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>typeof 基本类型，function， null可以用===判断</p>
<pre><code>typeof 100           // &quot;number&quot;   
typeof true          // &quot;boolean&quot;    
typeof function      // &quot;function&quot;    
typeof undefined     // &quot;undefined&quot;  
typeof new Object()  // &quot;object&quot;  
typeof [1, 2]        // &quot;object&quot;  
typeof NaN           // &quot;number&quot;  
typeof null          // &quot;object&quot;  </code></pre><p>instanceof</p>
<pre><code>// 不同window或iframe下返回false
[1, 2] instanceof Array === true  
new Object instanceof Array === fasle</code></pre><p>Object.prototype.toString</p>
<pre><code>Object.prototype.toString.apply([1, 2, 3]) === &quot;[object Array]&quot;;  
Object.prototype.toString.apply(function(){}) === &quot;[object Function]&quot;  
Object.prototype.toString.apply(null) === &quot;[object Null]&quot;  // ie678返回[object Object]  
Object.prototype.toString.apply(undefined) === &quot;[object Undefined]&quot;  
Object.prototype.toString.apply(12313) === &quot;[object Number]&quot;  
Object.prototype.toString.apply(&apos;12313&apos;) === &quot;[object String]&quot;</code></pre><p>constructor<br>duck type</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式是一种js短语，可使js解释器用来产生一个值</p>
<pre><code>// 原始表达式
3.14, &quot;test&quot;      // 常量，直接量
null, this, true  // 关键字
i, j, k;           // 变量

// 复合表达式
10 * 20;           // 原始表达式+运算符+原始表达式

// 初始化表达式
[1, 2];
[1,,2];
{x: 1, y: 2};

// 函数表达式
var fe = function(){};
(function(){console.log(&apos;1111&apos;);}){};

// 属性访问表达式
var o = {x:1};
o.x;
o[&apos;x&apos;];

// 调用表达式
func();

// 对象创建表达式
new Func(1, 2);
new Object;</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote>
<p>一元（+num）<br>二元（a + b）<br>三元（c：a：b） 赋值(x += 1)<br>比较(a == b)<br>算术（a - b）<br>位 （a | b）<br>逻辑 (exp1 &amp;&amp; exp2)<br>字符串(“a” + “b”)<br>特殊</p>
</blockquote>
<h3 id="特殊运算符"><a href="#特殊运算符" class="headerlink" title="特殊运算符"></a>特殊运算符</h3><blockquote>
<p>c? a:b<br>var val = (1, 2, 3) // 逗号运算符<br>delete obj.x // 删除对象属性<br>‘x’ in window; // in 运算符<br>instanceof, typeof // 判断类型<br>new Foo(); // new 运算符<br>this // this运算符<br>void 0 // undefined</p>
</blockquote>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>块语句block<br>块语句是没有作用域的</p>
<pre><code>{  
var str = &apos;hi&apos;;  
console.log(str);  
}  </code></pre><p>声明语句 var<br>var a=1, b=1; 函数语句function</p>
<pre><code>// 函数声明语句  
function fd() {  
    return true;  
}    
// 函数表达式  
var fe = function() {
    //do sth
};</code></pre><p>for in 语句</p>
<pre><code>var p;  
var obj = {x:1, y:2};  
for(p in obj) {
    // 顺序不确定  
}</code></pre><p>swith语句</p>
<pre><code>var val = 2;
switch (val) {
    case 1:
        console.log(1);
        break;
    case 2:
        console.log(2);
        break;
    case 3:
        console.log(3);
        break;
    default:
        console.log(0);
        break;
}</code></pre><p>循环语句</p>
<pre><code>while (isTrue) {
    // do sth
}

do {
    // do sth
} while (isTrue)

var i;
for (i = 0; i &lt; n; i++) {
    // do sth
}</code></pre><p>with语句 // 不使用 try catch语句</p>
<pre><code>try {
    try {
        throw new Error(&apos;oops&apos;);
    } catch(ex) {
        console.error(&apos;inner catch&apos;, ex.message);
        throw ex;
    } finally {
        console.log(&apos;inner  finally&apos;);
    }
} catch(ex) {
    console.error(&apos;outer catch&apos;, ex.message);
} finally {
    console.log(&apos;outer finally&apos;);
}</code></pre><p>结果 内部catch&gt;内部finally&gt;外部catch&gt;外部finally</p>
<pre><code>inner catch oops  
inner  finally  
outer catch oops  
outer finally  </code></pre><h3 id="严格模式-待补充）"><a href="#严格模式-待补充）" class="headerlink" title="严格模式(待补充）"></a>严格模式(待补充）</h3><pre><code>function func() {
    &apos;use strict&apos;;
}</code></pre><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象创建<br>字面量创建</p>
<pre><code>var obj = {x: 1};
console.log(obj);
console.log(obj.y);
Object.prototype.y = 2;
console.log(obj);
console.log(obj.y);
obj.y = undefined;
console.log(obj);
console.log(obj.y);


{ x: 1 }
undefined
{ x: 1 }
2
{ x: 1, y: undefined }
undefined</code></pre><p>new构造器创建</p>
<pre><code>function foo() { this.color = &apos;red&apos;;}
foo.prototype.background = &apos;#000&apos;;
var redColor = new foo();
console.log(redColor);
console.log(typeof redColor.toString);
console.log(redColor.color);
console.log(redColor.background);
console.log(foo);
console.log(foo.prototype);
console.log(foo.prototype.prototype);
console.log(&apos;background&apos; in redColor);
redColor.background = &apos;#FFF&apos;;
console.log(redColor.background);
console.log(foo.prototype.background);


foo { color: &apos;red&apos; }
function
red
#000
[Function: foo]
foo { background: &apos;#000&apos; }
undefined
true
#FFF
#000</code></pre><p>Object.create()创建</p>
<pre><code>function obj() {
    this.x = 1;
}
console.log(obj);
var obj1 = new obj();
console.log(obj1);
var obj2 = Object.create(obj);
console.log(obj2);
console.log(obj2.x);
var obj3 = Object.create(obj1);
console.log(obj3);
console.log(obj3.x);;


[Function: obj]
obj { x: 1 }
Function {}
undefined
obj {}
1</code></pre><h3 id="对象的内部原型-proto-和构造器的原型（prototype）的关系。"><a href="#对象的内部原型-proto-和构造器的原型（prototype）的关系。" class="headerlink" title="对象的内部原型(proto)和构造器的原型（prototype）的关系。"></a>对象的内部原型(<strong>proto</strong>)和构造器的原型（prototype）的关系。</h3><p>一、所有构造器/函数的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</p>
<pre><code>Number.__proto__ === Function.prototype  // true  
Boolean.__proto__ === Function.prototype // true  
String.__proto__ === Function.prototype  // true  
Object.__proto__ === Function.prototype  // true  
Function.__proto__ === Function.prototype // true  
Array.__proto__ === Function.prototype   // true  
RegExp.__proto__ === Function.prototype  // true  
Error.__proto__ === Function.prototype   // true  
Date.__proto__ === Function.prototype    // true  
Math.__proto__ === Object.prototype  // true  
JSON.__proto__ === Object.prototype  // true 
// 函数声明
function Person() {}
// 函数表达式
var Man = function() {}
console.log(Person.__proto__ === Function.prototype) // true  
console.log(Man.__proto__ === Function.prototype)    // true  </code></pre><p>所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind（ES5）</p>
<pre><code>console.log(typeof Function.prototype) // function
console.log(typeof Object.prototype)   // object
console.log(typeof Number.prototype)   // object
console.log(typeof Boolean.prototype)  // object
console.log(typeof String.prototype)   // object
console.log(typeof Array.prototype)    // object
console.log(typeof RegExp.prototype)   // object
console.log(typeof Error.prototype)    // object
console.log(typeof Date.prototype)     // object
console.log(typeof Object.prototype)   // object  
console.log(Function.prototype.__proto__ === Object.prototype) // true    
Object.prototype.__proto__ === null  // true  </code></pre><p>二、所有对象的<strong>proto</strong>都指向其构造器的prototype<br>JavaScript引擎内置构造器</p>
<pre><code>var obj = {name: &apos;jack&apos;}
var arr = [1,2,3]
var reg = /hello/g
var date = new Date
var err = new Error(&apos;exception&apos;)

console.log(obj.__proto__ === Object.prototype) // true
console.log(arr.__proto__ === Array.prototype)  // true
console.log(reg.__proto__ === RegExp.prototype) // true
console.log(date.__proto__ === Date.prototype)  // true
console.log(err.__proto__ === Error.prototype)  // true</code></pre><p>自定义的构造器</p>
<pre><code>function Person(name) {
    this.name = name
}
var p = new Person(&apos;jack&apos;)
console.log(p.__proto__ === Person.prototype) // true</code></pre><p>每个对象都有一个constructor属性，可以获取它的构造器</p>
<pre><code>function Person(name) {
    this.name = name
}
var p = new Person(&apos;jack&apos;)
console.log(p.__proto__ === p.constructor.prototype) // true</code></pre><h3 id="对象属性操作"><a href="#对象属性操作" class="headerlink" title="对象属性操作"></a>对象属性操作</h3><p>属性读写</p>
<pre><code>// 属性读写
var obj = {x1: 1, x2: 2};
var i = 1, n = 2;
for(; i&lt;= n; i++) {
    console.log(obj[&apos;x&apos; + i]);
}
// 输出1，2

var p;
for(p in obj) {
    console.log(obj[p]);
}
// 输出1，2

var obj = {x: 1};
// 读写异常
console.log(obj.y); // undefined
var yz = obj.y.z;  // TypeError: Cannot read property &apos;z&apos; of undefined
obj.y.z = 2;      //TypeError: Cannot set property &apos;z&apos; of undefined
// 正确方式
var yz;
if(obj.y) {
    yz = obj.y.z;
}
// 或者
var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z  // 这个会返回undefined</code></pre><p>属性删除</p>
<pre><code>var person = {age: 28, title: &apos;fe&apos;};
console.log(delete person.age);  // true
console.log(delete person[&apos;age&apos;]);  // true
console.log(person.age);  // undefined
console.log(delete person.age);   // 注意这个也返回true 判断操作结束后该属性是否存在

// 有些属性是不能删除的
console.log(delete Object.prototype);  // false

// 原因
var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);
console.log(descriptor.configurable);  // false

// 变量及函数不可删除
var globalVal = 1;
console.log(delete globalVal);  // false

(function() {
    var localVal = 1;
    console.log(delete localVal);
}());  // false

function fd() {}
console.log(delete fd);  // false

(function() {
    function fd() {};
    console.log(delete fd);
}());  // false


// 隐示定义的变量可以
ohNo = 1;
console.log(delete ohNo);  // true</code></pre><p>对象属性检测</p>
<pre><code>var cat = new Object();
cat.legs = 4;
cat.name = &apos;Kitty&apos;;

console.log(&apos;legs&apos; in cat);  // true
console.log(&apos;abc&apos; in cat);  // false
console.log(&apos;toString&apos; in cat);  // true 继承属性

console.log(cat.hasOwnProperty(&apos;legs&apos;));  // true
console.log(cat.hasOwnProperty(&apos;toString&apos;));  // false

console.log(cat.propertyIsEnumerable(&apos;legs&apos;));  // true
console.log(cat.propertyIsEnumerable(&apos;toString&apos;));  // false


Object.defineProperty(cat, &apos;price&apos;, {enumerable: false, value: 1000});
// defineProperty是Object的方法，默认的标签enumerable值为false
// Object.x创建属性，默认的标签值为true
console.log(cat.propertyIsEnumerable(&apos;price&apos;));  // false
console.log(cat.hasOwnProperty(&apos;price&apos;));  // true


// 判断属性是否存在
if(cat &amp;&amp; cat.legs) {
    cat.legs *= 2;
}

if(cat.legs != undefined) {
    // !== undefined 或者 !== null
}
if(cat.legs !== undefined) {
    // !== undefined
}</code></pre><p>对象属性枚举</p>
<pre><code>var o = {x: 1, y: 2, z: 3};
console.log(&apos;toString&apos; in o);  // true
o.propertyIsEnumerable(&apos;toString&apos;);  // false

var key;
console.log(o.x);  // 1
console.log(o.y);  // 2
console.log(o.z);  // 3
for(key in o) {
    console.log(key);  // x, y, z
    console.log(o.key);  // undefined
    console.log(o[key]);  // 1, 2, 3
}


var obj = Object.create(o);
obj.a = 4;
var key;
for(key in obj) {
    console.log(key); // a, x, y, z
}
var key1;
for (key1 in obj) {
    if(obj.hasOwnProperty(key1)) {
        console.log(key1); // a
    }
}</code></pre><p>对象属性的get/set方法</p>
<pre><code>// 对象属性的get/set方法
var man = {
    name: &apos;Bug&apos;,
    weibo: &apos;Bug&apos;,
    get age() {
        return new Date().getFullYear() - 1988;
    },
    set age(val) {
        console.log(&apos;cannot be set &apos; + val);
    },
};

console.log(man.age);  // 调用age的get方法27
man.age = 100;  // 调用age的set方法 cannot be set 100
console.log(man.age);  // 27


var man = {
    weibo: &apos;Bug&apos;,
    $age: null,
    get age() {
        if(this.$age == undefined) {
            return new Date().getFullYear() - 1988;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val; // 转为数字
        if(!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = + val;
        } else {
            throw new Error(&apos;Incorrect val = &apos; + val );
        }
    }
}

console.log(man.age);  // 27
man.age = 100;
console.log(man.age);  // 100
//man.age = &apos;abc&apos;;  // Error: Incorrect val = NaN


// get/set方法与原型链

// 这是错误的定义对象属性get方法方式
function foo1() {}
foo1.prototype.z = {
    get: function() {
        return 2;
    }
};
var obj = new foo1();
console.log(obj.z);  // 这个会被认为是对象 { get: [Function] }
obj.z = 200;
console.log(obj.z);  // 200

// 正确定义方法
function foo() {}
Object.defineProperty(foo.prototype, &apos;z&apos;, {
    get: function() {
        return 1;
    },
    // configurable: true,  // 开启此属于也不会被改变
    // writable: true,  // 此项不能配置writable/value get/set 二选一
 });
var obj = new foo();
console.log(obj.z);   // 1
obj.z = 100;
console.log(obj.z);  // 但是还是1 并没有被改变

Object.defineProperty(obj, &apos;z&apos;, {
    value: 100,
    configurable: true
});
console.log(obj.z);  // 100
delete obj.z;
console.log(obj.z);  // 返回到1

// 另外一个例子
var o = {};
Object.defineProperty(o, &apos;x&apos;, {
    value: 1
});  // 默认writable: false, configurable: false
var obj = Object.create(o);
console.log(obj.x);  // 1
obj.x = 100;
console.log(obj.x);  // 还是1


Object.defineProperty(obj, &apos;x&apos;, {
    writable: true,
    configurable: true,
    value: 100
});
console.log(obj.x);  // 100
obj.x = 200;
console.log(obj.x); // 200</code></pre><h3 id="对象属性标签"><a href="#对象属性标签" class="headerlink" title="对象属性标签"></a>对象属性标签</h3><pre><code>person = {};
Object.defineProperty(person, &apos;type&apos;, {
    configurable: false,
    writable: true,
    enumerable: false,
    value: &apos;Object&apos;,
});

console.log(Object.keys(person));   // [] 返回空数组，不能枚举
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));   // { value: &apos;Object&apos;, writable: true, enumerable: false, configurable: false }


// writable为true，可以通过赋值方法修改value值 [通过赋值修改属性值只和writable标签有关，和configurable无关]
person.type = &apos;Object2&apos;;
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));  // { value: &apos;Object2&apos;, writable: true, enumerable: false, configurable: false }


// configurable: false 无法使用delete删除属性， 无法使用get/set方法，  无法重新配置属性标签（除了将writable从true修改为false）
console.log(delete person.type);   // 返回false


// 只有writable和configurable标签都为false时，不能修改value标签值，其他情况都可以修改value标签值
Object.defineProperty(person, &apos;type&apos;, {
    configurable: false,
    writable: true,
    enumerable: false,
    value: &apos;Object1&apos;,
});
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));   // { value: &apos;Object1&apos;, writable: true, enumerable: false, configurable: false }


// 可以重新配置writable标签值(只能重true改为false)
Object.defineProperty(person, &apos;type&apos;, {
    writable: false,
});
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));   // { value: &apos;Object1&apos;, writable: false, enumerable: false, configurable: false }


// 无法将writable从false改为true
Object.defineProperty(person, &apos;type&apos;, {
    writable: true,
});
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));   // TypeError: Cannot redefine property: type


// 无法重新配置enumerable，configurable属性
Object.defineProperty(person, &apos;type&apos;, {
    enumerable: true,
});
console.log(Object.getOwnPropertyDescriptor(person, &apos;type&apos;));   // TypeError: Cannot redefine property: type</code></pre><h3 id="对象标签"><a href="#对象标签" class="headerlink" title="对象标签"></a>对象标签</h3><p>原型标签<strong>proto</strong></p>
<pre><code>// 原型标签__proto__

function Person(name) {
    this.name = name;
}
var p = new Person(&apos;jack&apos;);
console.log(p.__proto__ === Person.prototype);  // true</code></pre><p>类型标签</p>
<pre><code>//  对象class标签，表示对象是哪个类型，没有直接的方法去修改或者获取
var toString = Object.prototype.toString;

console.log(toString.call(null));  // [object Null]
console.log(toString.call(undefined));  // [object Undefined]
console.log(toString.call(1));  // [object Number]
console.log(toString.call(new Number(1)));  // [object Number]
console.log(toString.call(true));  // [object Boolean]
console.log(toString.call(new Boolean(true)));  // [object Boolean]</code></pre><p>可扩展标签</p>
<pre><code>// extensible 可扩展标签，表示是否可以继续添加对象属性
var obj = {x: 1, y: 2};
console.log(Object.isExtensible(obj));  // true 对象可扩展
Object.preventExtensions(obj);  // 配置对象不可扩展
console.log(Object.isExtensible(obj));  // false 对象不可扩展
obj.z =1;
console.log(obj.z);  // undefined 添加属性失败
console.log(Object.getOwnPropertyDescriptor(obj, &apos;x&apos;));  // // { value: 1, writable: true, enumerable: true, configurable: true }


// Object.seal方法，对象的所有属性configurable值为false
Object.seal(obj);
console.log(Object.getOwnPropertyDescriptor(obj, &apos;x&apos;));  // { value: 1, writable: true, enumerable: true, configurable: false }
console.log(Object.isSealed(obj)); // true


// Object.freeze方法，对象的所有属性configurable，writable标签值为false
Object.freeze(obj);
console.log(Object.getOwnPropertyDescriptor(obj, &apos;x&apos;));   // // { value: 1, writable: false, enumerable: true, configurable: false }
console.log(Object.isFrozen(obj));  // true</code></pre><h3 id="JS对象与json格式转换"><a href="#JS对象与json格式转换" class="headerlink" title="JS对象与json格式转换"></a>JS对象与json格式转换</h3><pre><code>// 将js对象转为json格式JSON.stringify()
var obj = {x: 1, y: true, z: [1, 2, 3], nullVal: null};
console.log(JSON.stringify(obj));  // {&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null}

// undefined,NaN,Infinity等特殊属性值
var obj = {val: undefined, a: NaN, b: Infinity, c: new Date()};
console.log(JSON.stringify(obj));  // {&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-12-19T12:30:40.456Z&quot;}

// 将json格式转为js对象JSON.parse
var obj = JSON.parse(&apos;{&quot;x&quot;: 1}&apos;);
console.log(obj.x);  // 1

//toJSON方法
var obj = {
    x: 1,
    y: 2,
    o: {
        o1: 1,
        o2: 2,
        toJSON: function() {
            return this.o1 + this.o2;
        }
    },
};
console.log(JSON.stringify(obj));  // {&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3}</code></pre><p>###toString valueOf方法</p>
<pre><code>// 对象在作为操作数时，解释器总是优先调用valueOf()--(Date类型的对象在二元“+”运算时例外),而其他情况，解释器总是认为我们想要的是字符串，所以会优先调用toString()。
var obj = {x: 1, y: 2};
console.log(obj.toString());  // [object Object]
console.log(+obj.toString());  // NaN
console.log(3 + obj.toString());  // 3[object Object] 会被理解为字符串拼接
console.log(+obj.valueOf());  // NaN

// 重写
obj.toString = function() {
    return this.x + this.y;
};
console.log(+obj);  // 3
obj.valueOf = function() {
    return this.x + this.y + 100;
};
console.log(+obj);  // 103

// 如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。

var cc = {
    i: 10,
    valueOf: function() {
        console.log(&apos;valueOf&apos;);
        return this.i;
    }
};

console.log(cc);// 10 { [Number: 10] i: 10, valueOf: [Function] }
console.log(+cc); // 10 valueOf
console.log(&apos;&apos;+cc); // 10 valueOf
console.log(String(cc)); // [object Object]
console.log(Number(cc)); // 10 valueOf
console.log(cc == &apos;10&apos;); // true valueOf</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>创建数组</p>
<pre><code>// 字面量创建数组 数组的长度不能超过2^23 - 1 = 4,294,967,295
var BAT = [&apos;B&apos;, &apos;A&apos;, &apos;T&apos;];
var students = [{name: &apos;B&apos;, age: 27}, {name: &apos;A&apos;, age: 30}];
var arr = [&apos;T&apos;, 123, true, null, undefined];
var arrInArr = [[1, 2], [1, 2, 3]];

// 对象创建数组 new关键字可以省略
var arr = new Array();  // var = [];
var arrWithLength = new Array(100);  // undefined * 100
var arrLikesLiteral = new Array(true, false, null, 1, 2, &apos;hi&apos;);  // [true, false, null, 1, 2, &apos;hi&apos;]</code></pre><p>数组元素操作</p>
<pre><code>// 数组元素读写

// 索引访问
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr[1]);  // b
console.log(arr.length);  // 5
arr[5] = &apos;f&apos;;
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]
console.log(arr.length);  // 6

// delete方法并不会改变数组长度,delete 和定义为undefined的区别
delete arr[0];
console.log(arr);  // [ , &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]
console.log(arr.length);  // 6
console.log(0 in arr);  // 会返回false
arr[1] = undefined;
console.log(arr);  // [ , undefined, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]
console.log(arr.length);  // 6
console.log(1 in arr);  // true

// 数组是动态的，无需指定大小

// 指定索引位置，改变数组
var arr = [];
arr[1] = &apos;b&apos;;
console.log(arr.length);  // 2
console.log(arr);   // [ , &apos;b&apos; ]

// push方法，在数组尾部添加元素,并返回新的数组长度
console.log(arr.push(&apos;c&apos;));  // 3
console.log(arr);  // [ , &apos;b&apos;, &apos;c&apos; ]

// 在数组尾部添加的另一种方法
arr[arr.length] = &apos;d&apos;;
console.log(arr);  // [ , &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]

// unshift方法，在数组头部添加元素，并返回新的数组长度
console.log(arr.unshift(&apos;a&apos;));  // 5
console.log(arr);  // [ &apos;a&apos;, , &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ]

// pop方法，删除数组尾部的元素并返回这个元素
console.log(arr.pop());  // &apos;d&apos;
console.log(arr);  // [ &apos;a&apos;, , &apos;b&apos;, &apos;c&apos; ]

// 删除数组尾部元素的另个方法
arr.length -= 1;
console.log(arr);  // [ &apos;a&apos;, , &apos;b&apos; ]

// shift方法，删除数组头部的元素并返回这个元素
console.log(arr.shift());  // &apos;a&apos;
console.log(arr);  // [ , &apos;b&apos; ]</code></pre><p>数组迭代</p>
<pre><code>// 数组迭代
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;];
for(var i = 0; i &lt; arr.length; i++) {
    console.log(arr[i]);
}
// a b c d e f g

for(i in arr) {
    console.log(arr[i]);
}
// a b c d e f g

// for in 表达式的坑：会迭代原型的元素
Array.prototype.x = &apos;keng&apos;;
for(i in arr) {
    console.log(arr[i]);
}
// a b c d e f g keng

for(i in arr) {
    if(arr.hasOwnProperty(i)) {
        console.log(arr[i]);
    }
}
// a b c d e f g</code></pre><p>特殊数组：二维数组和稀疏数组</p>
<pre><code>// 特殊数组：二维数组，稀疏数组
// 二维数组
var arr = [[&apos;a&apos;, &apos;b&apos;], [&apos;c&apos;, &apos;d&apos;], [&apos;e&apos;, &apos;f&apos;]];
var i = 0, j = 0;
var row;
for(; i &lt; arr.length; i++) {
    row = arr[i];
    console.log(&apos;row&apos; + i);
    for(j = 0; j &lt; row.length; j++) {
        console.log(row[j]);
    }
}
// row0 a b row1 c d row2 e f

// 稀疏数组：并不含有从0开始的连续索引
var arr1 = [undefined];
var arr2 = new Array(1);
console.log(0 in arr1);  // true
console.log(0 in arr2);  // false</code></pre><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><p>Array.prototype.join(separator)</p>
<pre><code>// Array.prototype.join(separator)方法：将数组拼接成字符串，返回字符串，不改变原数组
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
console.log(arr.join());  // a,b,c
console.log(arr.join(&apos;_&apos;));  // a,b,c
function repeatString(str, n) {
    return new Array(n + 1).join(str);
}
console.log(repeatString(&apos;a&apos;, 3));  // aaa
console.log(repeatString(&apos;Hi&apos;, 5));  // HiHiHiHiHi</code></pre><p>Array.prototype.reverse()</p>
<pre><code>// Array.prototype.reverse() 将数组逆序，返回数组本身，会改变数组本身
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
var arr1 = arr;
var arr2 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
console.log(arr.reverse());  // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ]
console.log(arr);  // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ]
console.log(arr1);  // [ &apos;c&apos;, &apos;b&apos;, &apos;a&apos; ]
console.log(arr2);  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]</code></pre><p>Array.prototype.sort(sortby）</p>
<pre><code>// Array.prototype.sort(sortby)方法：接受一个函数参数(不传参数默认按字符编码顺序)，返回数组本身，会修改原数组
var arr = [&apos;f&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;, &apos;a&apos;];
console.log(arr.sort());  // [ &apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]

var arr = [13, 24, 51, 3];
console.log(arr.sort());  // [ 13, 24, 3, 51 ]

// 传入参数：比较函数(a, b)
// 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
// 若 a 等于 b，则返回 0。
// 若 a 大于 b，则返回一个大于 0 的值。
function sortNumber(a, b) {
    return a - b;
}
console.log(arr.sort(sortNumber));  // [ 3, 13, 24, 51 ]

var arr = [{age: 25}, {age: 29}, {age: 40}];
console.log(arr.sort(function sortAge(a, b) {
    return a.age - b.age;
}));  // [ { age: 25 }, { age: 29 }, { age: 40 } ]</code></pre><p>Array.prototype.concat(arrayX, arrayY…..)</p>
<pre><code>// Array.prototype.concat(arrayX, arrayY.....)方法 连接多个数组，返回一个新的数组，不会改变原数组
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
console.log(arr.concat(&apos;d&apos;, &apos;e&apos;));  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
console.log(arr.concat([&apos;d&apos;, &apos;e&apos;], &apos;f&apos;));  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; ]
console.log(arr.concat([&apos;d&apos;, &apos;e&apos;], [&apos;f&apos;, &apos;g&apos;]));  // &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos; ]
console.log(arr.concat([[&apos;d&apos;, &apos;e&apos;], &apos;f&apos;]));  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, [ &apos;d&apos;, &apos;e&apos; ], &apos;f&apos; ]
console.log(arr.concat([[[&apos;d&apos;, &apos;e&apos;], &apos;f&apos;], &apos;g&apos;]));  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, [ [ &apos;d&apos;, &apos;e&apos; ], &apos;f&apos; ], &apos;g&apos; ]</code></pre><p>Array.prototype.slice(start, end)</p>
<pre><code>// Array.prototype.slice(start, end)方法：左闭右开截取数组，返回一个新的数组，不改变原数组
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.slice(1, 3));  // [&apos;b&apos;, &apos;c&apos;]
console.log(arr.slice(1));  // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]
console.log(arr.slice(1, -1));  // [&apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
console.log(arr.slice(-4, -3));  // [&apos;b&apos;]</code></pre><p>Array.prototype.splice(index, howmany, item1,….itemX)</p>
<pre><code>// Array.prototype.splice(index, howmany, item1,....itemX)方法：
// 向/从数组中添加/删除项目，然后返回被删除的项目。会改变原数组
// index参数：必须，整数，添加或删除的位置，左闭合
// howmany参数：可选，设置为0，则不会删除
// item1,.....itemX：可选，向数组中添加的元素

var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice(2));   // [ &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos; ]

var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice(2, 1));  // [ &apos;c&apos; ]
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;d&apos;, &apos;e&apos; ]

var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice(2, 0));  // []
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]

var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice(2, 2, &apos;f&apos;, &apos;g&apos;, [&apos;h&apos;, &apos;i&apos;]));  // [ &apos;c&apos;, &apos;d&apos; ]
console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;f&apos;, &apos;g&apos;, [ &apos;h&apos;, &apos;i&apos; ], &apos;e&apos; ]

// 指定位置插入新的元素
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice(2, 0, &apos;f&apos;));  // []
console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;f&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]

var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
console.log(arr.splice());  // []
console.log(arr); // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</code></pre><p>Array.prototype.forEach()</p>
<pre><code>// Array.prototype.forEach()方法(ES5)：接收函数参数
// 函数的3个参数x: 元素值，index：元素索引，a 数组本身
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;];
arr.forEach(function(x, index, a) {
    console.log(x + &apos;_&apos; + index + &apos;_&apos; + a);
});
// a_0_a,b,c,d,e b_1_a,b,c,d,e c_2_a,b,c,d,e d_3_a,b,c,d,e e_4_a,b,c,d,e</code></pre><p>Array.prototype.map()</p>
<pre><code>//Array.prototype.map()方法(ES5):接收函数参数,不会修改原数组
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
var arr1 = arr.map(function(x) {
    return x + &apos;like&apos;;
});

console.log(arr);  // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ]
console.log(arr1);  // [ &apos;alike&apos;, &apos;blike&apos;, &apos;clike&apos; ]</code></pre><p>Array.prototype.filter()</p>
<pre><code>// Array.prototype.filter()过滤方法(ES5):接收函数参数，不修改原数组
var arr = [1,2,3,4,5,6,7,8,9,10];
var arr1 = arr.filter(function(x, index) {
    return index % 3 === 0 || x &gt;= 8;
});
console.log(arr1);  // [ 1, 4, 7, 8, 9, 10 ]
console.log(arr);  // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</code></pre><p>Array.prototype.every() &amp; Array.prototype.some()</p>
<pre><code>// Array.prototype.every() &amp; Array.prototype.some()判断方法(ES5):接收函数参数，不修改原数组
// every 全部符合条件  some 只需一个符合条件
var arr = [1,2,3,4,5];
console.log(arr.every(function(x) {
    return x &lt; 10;
}));  // true
console.log(arr.every(function(x) {
    return x &lt;= 3;
}));  // false
console.log(arr.some(function(x) {
    return x === 3;
}));  // true
console.log(arr.some(function(x) {
    return x === 100;
}));  // false</code></pre><p>Array.prototype.reduce(function, index) Array.prototype.reduceRight(function, index)</p>
<pre><code>// Array.prototype.reduce(function, index) Array.prototype.reduceRight(function, index)方法
// 接收一个函数参数和一个数组索引参数，并返回一个值，不修改原数组
// 函数参加接收2个参数分别代表2个索引
// 索引参数表示从第index个元素开始
var arr = [1, 2, 3];
var sum = arr.reduce(function(x, y) {
    return x + y;
}, 0);
console.log(sum);  // 6  1+2返回3 3+3 返回6

var arr = [3, 9, 6];
var max = arr.reduce(function(x, y) {
    console.log(x + &apos;|&apos; + y);
    return x &gt; y ? x : y;
});
// 3|9
// 9|6
console.log(max);  // 9

var max = arr.reduceRight(function(x, y) {
    console.log(x + &apos;|&apos; + y);
    return x &gt; y ? x : y;
});
// 6|9
// 9|3
console.log(max);  // 9</code></pre><p>Array.prototype.indexOf(value, index) Array.prototype.lastIndexOf(value, index)</p>
<pre><code>// Array.prototype.indexOf(value, index) Array.prototype.lastIndexOf(value, index)数字检索方法
// value参数表示要查找的元素值，index表示从第几个索引位置开始查找(闭合)
var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;];
console.log(arr.indexOf(&apos;b&apos;));  // 1 在数组中查找是否有元素值为&apos;b&apos;，有则返回这个元素索引
console.log(arr.indexOf(&apos;f&apos;));  // -1 如果没有则返回-1
console.log(arr.indexOf(&apos;b&apos;, 1));  // 1 从第2个元素开始查找，返回索引1
console.log(arr.indexOf(&apos;b&apos;, 2));  // 3
console.log(arr.indexOf(&apos;b&apos;, -2));  // 3
console.log(arr.indexOf(&apos;b&apos;, -4));  // 1
console.log(arr.indexOf(&apos;b&apos;, -8));  // 1
console.log(arr.lastIndexOf(&apos;b&apos;));  // 3</code></pre><p>Array.isArray()</p>
<pre><code>// Array.isArray() 判断是否为数组
console.log(Array.isArray([]));  // true</code></pre><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><pre><code>// 函数声明
function add(a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
}

// 函数表达式
var add = function(a, b) {
    // do sth
};

// IEF(立即执行函数表达式)
(function() {
    // do sth
})();

// 函数表达式
return function () {
    // do sth
};

// NFE(命名式函数表达式)
var add = function foo(a, b) {
    // do sth
};</code></pre><p><strong>函数声明和函数表达式区别：函数声明会前置</strong></p>
<pre><code>var num = add(1, 2);
console.log(num);

function add(a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
}

// 结果为3


var num = add(1, 2);
console.log(num);

var add = function (a, b) {
    a = +a;
    b = +b;
    if (isNaN(a) || isNaN(b)) {
        return;
    }
    return a + b;
};

// TypeError: add is not a function</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>全局下的this</p>
<pre><code>// 全局下的this(浏览器下)
console.log(this.window === document);  // true
console.log(this === window);  // true
this.a = 37;
console.log(window.a);  // 37</code></pre><p>一般函数的this</p>
<pre><code>// 一般函数的this（浏览器下）
function f1() {
    return this;
}
f1() === window;  // true

function f2() {
    &quot;use strict&quot;;  // 严格模式下
    return this
}
f2() === undefined;  // true</code></pre><p>作为对象方法的函数的this</p>
<pre><code>var o = {
    prop: 37,
    f: function() {
        return this.prop;
    }
};
console.log(o.f());  // 37

var o = {prop: 37};
function  independent() {
    return this.prop;
}
o.f = independent;
console.log(o.f());  // 37</code></pre><p>原型链上的this</p>
<pre><code>var o = {
    f: function() {
        return this.a + this.b;
    }
};
var p = Object.create(o); // p为空对象，其原型会指向o
p.a = 1;
p.b = 4;
console.log(p.f())  // 5</code></pre><p>构造器中的this</p>
<pre><code>// 当new的函数构造器没有return返回值或者返回值不是对象时，new返回一个this指向构造器的prototype这样一个空对象
// 如果return返回的是对象 new返回的这是这个对象
function Myclass() {
    this.a = 37;
}
var o = new Myclass();
console.log(o.a);  // 37

function C2() {
    this.a = 37;
    return {a: 38};
}
o = new C2();
console.log(o.a);  // 38</code></pre><p>call和apply的this</p>
<pre><code>function add(c, d) {
    return this.a + this.b + c + d;
}
var o = {a: 1, b: 2};
add.call(o, 5, 6);  // 1+3+5+7=16
add.apply(o, [10, 20]);  //1+3+10+20=34

function bar() {
    console.log(Object.prototype.toString.call(this));
}
bar.call(7); // [object Number]</code></pre><p>band和this</p>
<pre><code>//bind是es5后，ie9+使用
function f() {
    return this.a;
}
var g = f.bind({a: &apos;test&apos;});
console.log(g());  // test
var o = {
    a: 37,
    f: f,
    g: g
};
console.log(o.f(), o.g());  // 37, test</code></pre><p>函数arguments属性</p>
<pre><code>function foo(x, y, z) {
    arguments.length;  // 2 实际传入的参数数量
    arguments[0];  // 1 传入第一个参数值
    arguments[0] = 10;
    x;  // 10 将第一个参数值修改为10， 严格模式下任然是1
    arguments[2] = 100;
    z; // undefined  由于第三个参数没有传入，不会绑定
    arguments.callee  === foo;  // true   严格模式下不能使用
}

foo(1, 2);
foo.length;  // 3   3个参数
foo.name;  // &quot;foo&quot; 函数名</code></pre><h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><pre><code>// apply和call方法（浏览器）
// 第一个参数是作为this的对象，如果不是对象，会转换为对象
// call传入的是扁平传入参数
// apply第二个参数树数组
function foo(x, y) {
    console.log(x, y, this);
}

foo.call(100, 1, 2);  // 1, 2, Number(100)
foo.apply(true, [3, 4]);  //3, 4, Boolean(true)
foo.apply(null);  // undefined, undefined, window
foo.apply(undefined);  // undefined, undefined, window</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>bind方法：改变this</p>
<pre><code>// bind方法
this.x = 9;
var module = {
    x: 81,
    getX: function() {
        return this.x;
    }
};

module.getX();  // 81 this指向module

var getX = module.getX;
getX();  // 9 this指向全局变量

var boundGetX = getX.bind(module);
boundGetX();  // 81  bind改变this指向</code></pre><p>bind方法：科里化</p>
<pre><code>// bind方法
function add(a, b, c) {
    return a+b+c;
}

var func = add.bind(undefined, 100);
func(1, 2);  // 103  undefined传给this， 100传给第一个参数a

var func2 = func.bind(undefined, 200);
func2(10);  // 310 undefined传给this，200传给b</code></pre><p>bind与new</p>
<pre><code>// bind方法与new
function foo() {
    this.b = 100;
    return this.a;
}

var func = foo.bind({a: 1});

func(); // 1  foo.bind后this指向{a: 1} return this.a = 1
new func();  // {b: 100} new调用将返回一个this，this会被初始化一个空对象，并且其原型是foo.prototype,空对象的b属性为100</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包基本概念</p>
<pre><code>// 闭包
var n = 999;
function f1() {
    console.log(n);
}
f1();  // 999  函数内部可以访问全局变量

function f1() {
    var n = 999;
}
console.log(n);  // error  函数外部无法访问函数内部局部变量

function f1() {
    n = 999;
}
console.log(n); // 999 因为没有使用var语句，相当于定义一个全局变量


// 简单的闭包原型
function f1() {
    var n = 999;
    function f2() {
        console.log(n);
    }
    return f2
}
var result = f1();
result();  // 999</code></pre><p>闭包案例</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color: rosybrown;
        }
        #div2 {
            background-color: aquamarine;
        }
        #div3 {
            background-color: yellowgreen;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;script&gt;
    document.body.innerHTML = &apos;&lt;div id=&quot;div1&quot;&gt;aaa&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;ccc&lt;/div&gt;&apos;;
    for(var i = 1; i &lt; 4; i++) {
        alert(i);  // 结果为1，2，3
        document.getElementById(&apos;div&apos; + i).
                addEventListener(&apos;click&apos;, function() {
            alert(i);  // 点击div1，div2，div3结果都是4,因为addEventListener的回调函数执行时i都为4
        });
    }
&lt;/script&gt;
&lt;/html&gt;</code></pre><p>正确写法</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color: rosybrown;
        }
        #div2 {
            background-color: aquamarine;
        }
        #div3 {
            background-color: yellowgreen;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;script&gt;
    document.body.innerHTML = &apos;&lt;div id=&quot;div1&quot;&gt;aaa&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;bbb&lt;/div&gt;&lt;div id=&quot;div3&quot;&gt;ccc&lt;/div&gt;&apos;;
    for(var i = 1; i &lt; 4; i++) {
        !function(i) {
            alert(i);  // 1,2,3
            document.getElementById(&apos;div&apos; + i).
               addEventListener(&apos;click&apos;, function() {
                   alert(i);  // 1, 2,3 
            });
        }(i);
    }
&lt;/script&gt;
&lt;/html&gt;</code></pre><p>闭包中的封装</p>
<pre><code>(function() {
    var _userID = 23245;
    var _typeID = &apos;item&apos;;
    var exportID = {};

    function converter(userID) {
        return +userID;
    }

    exportID.getUserID = function() {
        return converter(_userID);
    };

    exportID.getTypeID = function() {
        return _typeID;
    };
    global.exportID = exportID;
}());

console.log(exportID.getUserID());  //23245
console.log(exportID._userID);  // undefined</code></pre><h3 id="三种作用域"><a href="#三种作用域" class="headerlink" title="三种作用域"></a>三种作用域</h3><pre><code>// 作用域： 全局作用域，函数作用域，eval作用域
var a = 10;
(function() {
    var b = 20;
})();
console.log(a);  // 10
console.log(b);  // error

for(var item in {a: 1, b: 2}) {
    console.log(item);  // a, b
}
console.log(item); // b</code></pre><h3 id="ES3中的执行上下文"><a href="#ES3中的执行上下文" class="headerlink" title="ES3中的执行上下文"></a>ES3中的执行上下文</h3><p>EC = Execution Context 执行上下文<br>变量对象（Variable Object 简写VO）是一个抽象概念，用于存储执行上下文中的变量，函数声明，函数参数</p>
<pre><code>var a = 10;
function test(x) {
    var b = 20;
}
test(30);</code></pre><p>对应的上下文</p>
<pre><code>// 整个js环境中的VO
VO(globalContext) = {
    a: 10,
    test: &lt;ref to function&gt;
};
// 执行test(30)的VO
VO(test functionContext) = {
    x: 30,
    b: 20
};</code></pre><p>全局执行上下文</p>
<pre><code>VO(globalContext) === [[global]]
[[global]] = {
    Math : &lt;...&gt;,
    String : &lt;...&gt;,
    isNaN: function() {[Native Code]},
    ...
    ...
    window: global
};

String(10);  //[[global]].String(10)
window.a = 10;  // [[global]].window.a = 10
this.b = 20;  // [[global]].b = 20</code></pre><p>变量初始化阶段</p>
<pre><code>// 1, 函数参数（若没有传入，则其值为undefined）
// 2, 函数声明（若函数声明和函数参数冲突，则函数声明会覆盖掉函数参数）
// 3，变量声明（初始化变量值为undefined，若何函数参数，函数声明冲突，会被忽略掉）
function test(a, b) {
    var c = 10;
    function d() {}
    var e = function _e() {};
    (function x() {});
    b = 20;
}
test(10);


AO(test) = {
    a: 10,
    b: undefined,
    c: undefined,
    d: &lt;ref to func &apos;d&apos;&gt;,
    e: undefined,
};</code></pre><p>变量初始化案例1</p>
<pre><code>function foo(x, y, z) {
    function x() {}
    console.log(x);
}

foo(100);  // [Function: x]
//
AO(foo) = {
    //x: 100,
    y: undefined,
    z: undefined,
    x: &lt;ref to func &apos;x&apos;&gt;,  // 函数声明x会覆盖掉参数声明 
}</code></pre><p>变量初始化案例2</p>
<pre><code>function foo(x, y, z) {
    function func() {}
    var func;
    console.log(func);
}
foo(100);  // [Function: func]

function foo(x, y, z) {
    function func() {}
    var func = 1;
    console.log(func);
}
foo(100);  // 1  执行阶段会执行func = 1 这个语句</code></pre><p>代码执行阶段</p>
<pre><code>function test(a, b) {
    var c = 10;
    function d() {}
    var e = function _e() {};
    (function x() {})();
    b = 20;
}

// 初始化阶段
AO(test) = {
    a: 10,
    b: undefined,
    c: undefined,
    d: &lt;ref to func &apos;d&apos;&gt;,
    e: undefined
};
// 代码执行阶段
AO(test) = {
    a: 10,
    b: 20,
    c: 10,
    d: &lt;reference to FunctionDeclaration &apos;d&apos;&gt;,
    e: function _e()
};</code></pre><p>全局执行上下文案例</p>
<pre><code>console.log(x);  // [Function: x]
var x = 10;  // 初始化阶段x: 冲突，被忽略
console.log(x);  // 10
x = 20;
function x() {}  // 初始化阶段x: &lt;ref to func &apos;x&apos;&gt;
console.log(x);  // 20
if (true) {
    var a = 1;  // 初始化阶段a: undefined
} else {
    var b = true;  // 初始化阶段b: undefined
}

console.log(a);  // 1
console.log(b);  // undefined</code></pre><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>prototype是函数对象上的预设的对象属性<br>原型是对象上的原型，通常都是构造器的prototype属性<br>实例</p>
<pre><code>function Abc() {
    this.y = 2;
    var z = 3;
}
console.log(Abc);  // [Function: Abc]
console.log(Abc.prototype);  // Abc {}
console.log(typeof Abc.prototype);  // object

Abc.prototype.x = 1;
console.log(Abc.prototype);  // Abc { x: 1 }

var obj1 = new Abc();
console.log(obj1.__proto__);  // Abc { x: 1 }
console.log(obj1.__proto__ === Abc.prototype);  // true  new构造器创建的对象的原型是构造器的prototype属性
console.log(obj1);  // Abc { y: 2 }
console.log(obj1.y);  // 2
console.log(obj1.x);  // 1</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>实现继承的方法</p>
<pre><code>// 实现继承的方法
function Person() {
}

function Student() {
}

Student.prototype = Person.prototype;  // 错误，会影响被继承类的方法
Student.prototype = new Person();  // 错误，传参问题，因为Student是类，并不是实例

// 正确的方法
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
// Object.create()是es5的方法，下面是fix方法
if(!Object.create) {
    Object.create = function(proto) {
        function F() {}
        F.prototype = proto;
        return new F;
    };
}</code></pre><p>原型的继承方法</p>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayNo = function() {
        console.log(this.name + &apos; say no&apos;);
    }
}

Person.prototype.hi = function() {
    console.log(&apos;Hi, my name is &apos; + this.name + &apos;,I\&apos;m &apos; + this.age + &apos; years old now&apos;);
};
Person.prototype.LEGS_NUM = 2;
Person.prototype.ARMS_NUM = 2;
Person.prototype.walk = function() {
    console.log(this.name + &apos; is walking...&apos;);
};

console.log(Person);  // [Function: Person]
console.log(Person.prototype);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }
var Jack = new Person();  // Person构造器没有return对象，所以返回的是this
Jack.sayNo();  // undefined say no
Jack.hi();  // Hi, my name is undefined,I&apos;m undefined years old now
Jack.walk();  // undefined is walking...
console.log(Jack);  // Person { name: undefined, age: undefined, sayNo: [Function] }
console.log(Jack.__proto__);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }

// 以下5行代码是js中对象继承的写法
function Student(name, age, className) {
    Person.call(this, name, age);  // 使用call方法调用父构造器函数
    this.className = className;
}
Student.prototype = Object.create(Person.prototype);   // 这个如果直接使用Student.prototype = Person.prototype，改变Student对象方法会改变Person对象的方法，因为他们指向的是同一个对象
Student.prototype.constructor = Student;

Student.prototype.hi = function() {
    console.log(&apos;Hi, my name is &apos; + this.name + &apos;, I\&apos;m&apos; + this.age + &apos; years old now, and from &apos; + this.className + &apos;.&apos;);
};
Student.prototype.learn = function(subject) {
    console.log(this.name + &apos; is learning &apos; + subject + &apos; at &apos; + this.className + &apos;.&apos;);
};

var Lussi = new Student(&apos;Lussi&apos;, 27, &apos;Class Tree&apos;);
Lussi.sayNo();  // Lussi say no
Lussi.hi();  // Hi, my name is Lussi, I&apos;m27 years old now, and from Class Tree.
Lussi.walk();  // Lussi is walking...
Lussi.learn(&apos;math&apos;);  // Lussi is learning math at Class Tree.
console.log(Lussi);  // Student {name: &apos;Lussi&apos;, age: 27, sayNo: [Function], className: &apos;Class Tree&apos; }
console.log(Lussi.__proto__);  // Student {constructor: [Function: Student], hi: [Function], learn: [Function] }
console.log(Lussi.__proto__.__proto__);  // Person { hi: [Function], LEGS_NUM: 2, ARMS_NUM: 2, walk: [Function] }
console.log(Lussi.__proto__.__proto__.__proto__);  // {}
console.log(Lussi.__proto__.__proto__.__proto__.__proto__);  // null  
// 改变prototype
Student.prototype.x = 101;  // 会影响已经创建实例的属性
console.log(Jack.x);  // undefined
console.log(Lussi.x);  // 101

Student.prototype = {y: 2};  // 不会影响已经创建实例的属性，但会影响新创建的实例，并且重新修改prototype.y属性也不会改变
console.log(Jack.y); // undefined
console.log(Lussi.y);  // undefined
var Lilei = new Student(&apos;Lilei&apos;, 24, &apos;Class three&apos;);
console.log(Lilei.x);  // undefined
console.log(Lilei.y);  // 2
Student.prototype.y = 100;
console.log(Lilei.y);  // 100
console.log(Lussi.y);  // undefined
Student.prototype.z = 30;
console.log(Lilei.z);  // 30
console.log(Lussi.z);  // undefined
Person.prototype.z = 40;
console.log(Lilei.z);  // 30
console.log(Lussi.z);  // 40
console.log(Jack.z);  // 40</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><pre><code>// instanceof  左边是对象（如果不是，直接返回false），右边是构造器（如果不是，直接报错），判断构造器的prototype属性是否在对象的原型链上
console.log([1, 2] instanceof Array);  // true
console.log(1 instanceof Array);  // false
console.log(Array.prototype);  // []
console.log(new Object() instanceof Array);  //false
console.log(Object.prototype);  // {}
console.log(new Object() instanceof Object);  // true
console.log(new Array() instanceof Object);  // true</code></pre><h3 id="模拟重载"><a href="#模拟重载" class="headerlink" title="模拟重载"></a>模拟重载</h3><pre><code>function Person() {
    var args = arguments;
    // 判断第一个传入的是不是对象，因为args[null]也返回object，所有需要判断是否为null
    if(typeof args[0] === &apos;object&apos; &amp;&amp; args[0]) {
        if(args[0].name) {
            this.name = args[0].name;
        }
        if(args[0].age) {
            this.age = args[0].age;
        }
    } else {
        if(args[0]) {
            this.name = args[0];
        }
        if(args[1]) {
            this.age = args[1];
        }
    }
}
Person.prototype.toString = function() {
    console.log(&apos;name=&apos; + this.name + &apos;, age=&apos; + this.age);
};

var LiLei = new Person(&apos;LiLei&apos;, 23);
var Hanmm = new Person({name: &apos;Hanmm&apos;, age: 21});
LiLei.toString();  // name=LiLei, age=23
Hanmm.toString();  // name=Hanmm, age=21</code></pre><h3 id="调用子类方法"><a href="#调用子类方法" class="headerlink" title="调用子类方法"></a>调用子类方法</h3><pre><code>function Person(name) {
    this.name = name;
}
function Student(name, className) {
    this.className = className;
    Person.call(this, name);
}

Person.prototype.init = function() {
    console.log(&apos;Person.init&apos;);
};
Student.prototype.init = function() {
    console.log(&apos;Student.init&apos;);
    Person.prototype.init.apply(this, arguments);
};
var LiLei = new Student(&apos;LiLei&apos;, &apos;Class four&apos;);
console.log(LiLei);  // Student { className: &apos;Class four&apos;, name: &apos;LiLei&apos; }
LiLei.init();  // Student.init  Person.init</code></pre><h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><pre><code>function ClassManager() {
    console.log(&apos;ClassManager&apos;);
    this.name = &apos;ClassName&apos;;
}
ClassManager.prototype.addClass = function(str) {
    console.log(&apos;class: &apos;  + str + &apos; added.&apos;);
    console.log(this);
    return this;  // this始终指向ClassManger类的实例
};

var manager = new ClassManager();
manager.addClass(&apos;A&apos;).addClass(&apos;B&apos;).addClass(&apos;C&apos;);  //class: A added. ClassManager { name: &apos;ClassName&apos; } class: B added. ClassManager { name: &apos;ClassName&apos; } class: C added. ClassManager { name: &apos;ClassName&apos; }</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.zhuohc.com/2016/11/10/javascript-e5-9f-ba-e7-a1-80-e5-85-a5-e9-97-a8/" data-id="cjyfelqxj0055cta4ziuoifdf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/11/10/centos7-e6-9c-8d-e5-8a-a1-e5-99-a8-e5-9f-ba-e7-a1-80-e9-85-8d-e7-bd-ae/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Centos7服务器基础配置
        
      </div>
    </a>
  
  
    <a href="/2016/11/10/css-e5-85-bc-e5-ae-b9-e6-80-a7-e6-b1-87-e6-80-bb/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CSS兼容性汇总</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/办公/">办公</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/办公/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/办公/后端/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/办公/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/后端/运维/">运维</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bash/">bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/django/">django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/">windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微信/">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IDE/" style="font-size: 12.5px;">IDE</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/ubuntu/" style="font-size: 12.5px;">ubuntu</a> <a href="/tags/windows/" style="font-size: 17.5px;">windows</a> <a href="/tags/微信/" style="font-size: 10px;">微信</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/23/测试blog/">测试blog</a>
          </li>
        
          <li>
            <a href="/2019/07/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/11/17/e5-9c-a8bash-e6-98-be-e7-a4-bagit-e5-88-86-e6-94-af-e4-bf-a1-e6-81-af/">在bash显示git分支信息</a>
          </li>
        
          <li>
            <a href="/2018/11/16/zabbix-e5-ae-89-e8-a3-85-e5-8f-8a-e4-bd-bf-e7-94-a8/">zabbix安装及使用</a>
          </li>
        
          <li>
            <a href="/2018/11/14/centos7-2-e5-ae-89-e8-a3-85-e4-bd-bf-e7-94-a8openresty/">centos7.2安装使用openResty</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 www.zhuohc.om<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>